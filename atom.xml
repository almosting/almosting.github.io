<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fwrite</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-30T06:19:32.692Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fwrite</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络知识</title>
    <link href="http://example.com/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</id>
    <published>2022-06-30T05:36:50.000Z</published>
    <updated>2022-06-30T06:19:32.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote><p>面向报文</p></blockquote><p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><blockquote><p>不可靠性</p></blockquote><ol><li>UDP 是无连接的，也就是说通信不需要建立和断开连接。</li><li>UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li><li>UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li></ol><blockquote><p>高效</p></blockquote><p>因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-13-40-10.png" alt="2022-06-30-13-40-10"></p><p>头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><blockquote><p>传输方式</p></blockquote><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-13-40-38.png" alt="2022-06-30-13-40-38"></p><p>对于 TCP 头部来说，以下几个字段是很重要的</p><ul><li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li>Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li>Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制</li><li>标识符</li><li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li><li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li>SYN=1：当 SYN=1，ACK=0 时，表示当前报文段是一个连接请求报文。当 SYN=1，ACK=1 时，表示当前报文段是一个同意建立连接的应答报文。</li><li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul><blockquote><p>状态机</p></blockquote><p>HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态</p><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-13-41-05.png" alt="2022-06-30-13-41-05"></p><p>TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。</p><p>在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p><blockquote><p>三次握手</p></blockquote><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-13-42-09.png" alt="2022-06-30-13-42-09"></p><p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。</p><p>起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据</p><ul><li>第一次握手</li></ul><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p><ul><li>第二次握手</li></ul><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><ul><li>第三次握手</li></ul><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。</p><blockquote><p>四次挥手</p></blockquote><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-14-08-37.png" alt="2022-06-30-14-08-37"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p><ul><li>第一次握挥手</li></ul><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><ul><li>第二次挥手</li></ul><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p><ul><li>第三次挥手</li></ul><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p><p>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p><ul><li>第四次挥手</li></ul><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><p>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</p><p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p><h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ</p><blockquote><p>正常传输过程</p></blockquote><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><blockquote><p>报文丢失或出错</p></blockquote><p>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。</p><p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p><blockquote><p>ACK 超时或丢失</p></blockquote><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK。</p><h2 id="连续-ARQ"><a href="#连续-ARQ" class="headerlink" title="连续 ARQ"></a>连续 ARQ</h2><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p><blockquote><p>累计确认</p></blockquote><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1 的数据。</p><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到。</p><blockquote><p>拥塞处理</p></blockquote><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p><p>慢开始算法</p><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p><p>慢开始算法步骤具体如下</p><ol><li>连接初始设置拥塞窗口（Congestion Window）为 1 MSS（一个分段的最大数据量）</li><li>每过一个 RTT 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ol><p>拥塞避免算法</p><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>启动拥塞避免算法</li></ul><p>快速重传</p><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p><p>TCP Taho 实现如下</p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>重新开始慢开始算法</li></ul><p>TCP Reno 实现如下</p><ul><li>拥塞窗口减半</li><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li><li>使用拥塞避免算法</li></ul><p>TCP New Ren 改进后的快恢复</p><p>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 协议是个无状态协议，不会保存状态。</p><p>Post 和 Get 的区别</p><p>先引入副作用和幂等的概念。</p><p>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p><p>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。</p><p>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p><p>在技术上说：</p><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li><li>Post 可以通过 request body 来传输比 Get 更多的数据，Get 没有这个技术</li><li>URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li><li>Post 支持更多的编码类型且不对数据类型限制</li></ul><blockquote><p>常见状态码</p></blockquote><p>2XX 成功</p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><p>3XX 重定向</p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p>4XX 客户端错误</p><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><p>5XX 服务器错误</p><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><blockquote><p>HTTP 首部</p></blockquote><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存行为</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型，比如 keep-alive</td></tr><tr><td>Date</td><td>创建报文时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td>传输编码方式</td></tr><tr><td>Warning</td><td>在内容中可能存在错误</td></tr><tr><td>Upgrade</td><td>要求客户端升级协议</td></tr></tbody></table><table><thead><tr><th>响应字段</th><th>作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否支持某些种类的范围</td></tr><tr><td>Age</td><td>资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td>资源标识</td></tr><tr><td>Location</td><td>客户端重定向到某个 URL</td></tr><tr><td>Proxy-Authenticate</td><td>向代理服务器发送验证信息</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>WWW-Authenticate</td><td>WWW-Authenticate</td></tr></tbody></table><table><thead><tr><th>实体字段</th><th>作用</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td>内容的编码格式</td></tr><tr><td>Accept-Encoding</td><td>正确接收的编码格式列表</td></tr><tr><td>Content-Language</td><td>内容使用的语言</td></tr><tr><td>Content-Length</td><td>request body 长度</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64 加密格式的内容 MD5 检验值</td></tr><tr><td>Content-Range</td><td>内容的位置范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT，接下来可以通过 Session Resumption 减少到一个 RTT。</p><p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p><p>对称加密：</p><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><p>非对称加密：</p><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>TLS 握手过程如下图：</p><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-14-03-40.png" alt="2022-06-30-14-03-40"></p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol><p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p><p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p><p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><blockquote><p>二进制传输</p></blockquote><p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><p><img src="/2022/06/30/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/2022-06-30-14-04-02.png" alt="2022-06-30-14-04-02"></p><blockquote><p>多路复用</p></blockquote><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p><p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><blockquote><p>Header 压缩</p></blockquote><p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p><blockquote><p>服务端 Push</p></blockquote><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS 的作用就是通过域名查询到具体的 IP。</p><p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p><p>在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 <a href="http://www.google.com/">www.google.com</a> 时，会进行一下操作：</p><ol><li>操作系统会首先在本地缓存中查询</li><li>没有的话会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google 这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li></ol><p>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p><p>PS：DNS 是基于 UDP 做的查询。</p><p>从输入 URL 到页面加载完成的过程</p><ol><li>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来</li><li>接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li><li>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据</li><li>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</li><li>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li><li>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</li><li>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</li><li>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</li><li>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li><li>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;面向报文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UDP 是一个面向报文（报文可以理解为一段段的数据）的</summary>
      
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Android Performance</title>
    <link href="http://example.com/2022/06/28/Performance/"/>
    <id>http://example.com/2022/06/28/Performance/</id>
    <published>2022-06-28T12:06:56.000Z</published>
    <updated>2022-06-30T01:20:01.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析-Android-Performance-问题"><a href="#分析-Android-Performance-问题" class="headerlink" title="分析 Android Performance 问题"></a>分析 Android Performance 问题</h1><h2 id="CPU-问题"><a href="#CPU-问题" class="headerlink" title="CPU 问题"></a>CPU 问题</h2><p>查看 cpu 频率：</p><p><code>cat /sys/devices/system/cpu/cpux/cpufreq/scaling_curfreq</code></p><h2 id="TOP-信息"><a href="#TOP-信息" class="headerlink" title="TOP 信息"></a>TOP 信息</h2><blockquote><p>查看 TOP 消息，查看后台是否干净，查看 idle 是否异常</p></blockquote><p><code>system 1%(1),IOW 10%(2)</code></p><ul><li><p>(1) 该值高就需要查看进程，看 CPU 占比</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell top -d 1 -m 10 -t</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&quot;-d 1&quot;: 每一秒刷一次</span><br><span class="line"></span><br><span class="line">*&quot;-m 10&quot;: 输出前10个</span><br><span class="line"></span><br><span class="line">*&quot;-t&quot;: 输出线程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果需要查看进程的 call stack，使用如下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell touch /data/anr/traces.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell <span class="built_in">kill</span> -3 [PID](进程号)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>(2) 如果 IOW 偏高，先关闭怀疑的进程，如果还是高，需要查看是否系统 IO 占用高</p></li></ul><h2 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h2><h2 id="Bugreport"><a href="#Bugreport" class="headerlink" title="Bugreport"></a>Bugreport</h2><h2 id="Vmstat-工具"><a href="#Vmstat-工具" class="headerlink" title="Vmstat 工具"></a>Vmstat 工具</h2><p><strong>vmstat: virtual Memory Statistics (虚拟内存统计)</strong>, 是一个很有价值的监控工具，可以实时提供 memory、block IO 和 CPU 状态信息。它用来对系统整体的情况进行统计，通过它可以快速了解当前系统运行情况及可能碰到的问题。</p><p>使用方式：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vmstat 1 10</span><br><span class="line"></span><br><span class="line">usage: vmstat [-n][DELAY [COUNT]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----</span><br><span class="line"></span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa</span><br><span class="line"></span><br><span class="line"> 0  0      0  57080  50060 1429612   0    0   712    67    0  237 10  6 83  0</span><br><span class="line"></span><br><span class="line"> 0  0      0  57064  50060 1429612   0    0     0     0    0  181  0  0 100 0</span><br><span class="line"></span><br><span class="line"> 0  0      0  57064  50060 1429612   0    0     0     0    0  100  0  0 100 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Pocs"><a href="#Pocs" class="headerlink" title="Pocs"></a>Pocs</h3><p>-<strong>r:</strong>(running) 运行队列中的进程数，这个值超过 CPU 的个数就会出现瓶颈</p><p>-<strong>b：</strong>(blocked) 被阻塞的进程数，通常是进程等待 IO 操作</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul><li>swpd 虚拟内存大小，大于 0，表示物理内存不足，可能出现泄漏，或者后台 activity 或者 jobs 太多</li><li>free 可用物理内存</li><li>buff 系统用作 buffers 的内存</li><li>cache 系统用作 cache 的内存数，可以理解为缓存</li></ul><h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><ul><li>si 每秒从磁盘读入内存的大小，如果大于 0，表示物理内存不足或者内存泄漏</li><li>so 每秒从内存写入磁盘的大小</li></ul><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ul><li>bi 块设备接收的块数量 代表 io 操作，如 copy</li><li>bo 块设备每秒发送的块数量，如读取文件</li></ul><p>一般 bi bo 都要接近 0，否则 io 过于频繁</p><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><ul><li><p>in(interrupts) 在 delay(默认为 1s) 时间内系统产生的中断数，值过大，可以通过 <code>cat /proc/interrupts</code>查看哪个模块中断产生过多</p></li><li><p>cs(context switch) 在 delay 时间内，系统上下文切换次数，这个值越小越好，太大证明</p><p>CPU 大部分时间浪费在上下文切换去了，一般需要查看中断和线程调度</p></li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li>us 用户占用的 CPU 时间比，占比高，需要查看进程是否有闭环代码</li><li>sy 系统时间占用 CPU 时间比，太高，表示系统调用时间长，需要关心 IO 等操作</li><li>id idle 闲置 CPU 时间比</li><li>wa IO wait CPU 等待 IO 完成的时间占比，值太大，对系统负担大</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li>如果 r 值经常大于 1 或者更大，并且 id 常小于 40%，说明 CPU 负荷过重。</li><li>当手机正常使用时，有较小的 free 是好事，说明 cache 使用更有效率，除非此时有不断的写入 swap，disk (so, bo). cache 值如果偏大，且 bi 值小，表示 data 存于 cache 中不必块读取，使用效率高。Android 中当内存不够时会由 oom killer 来根据优先级顺序将不太重要的后台 cached 进程杀掉来释放这段内存。当该值忽大忽小时，需要注意是否有 cache 被清理出去，cache 对系统的性能和流畅性影响很大。</li><li>如果 swapd 值大于 0，而 si，so 都显示 0，此时系统性能还是正常的。</li><li>如果 free 值很少或者接近 0 并不代表内存不够用，此时如果 si，so 也很少（大多时候是 0）系统性能不会受到影响的。</li><li>如果 bi，bo 出现较大值，而 si，so 却维持在 0 值，表示系统 IO 负载过重，要查看 IO 处理或者 Rom 是否有异常。</li><li>如果 bi，bo 和 si，so 同时为较大数值，表示内存 swapping 频繁，RAM 太小。</li><li>bi 或 bo 出现 0 的次数太过频繁，除非是系统处于闲置状态，否则需要查看 I/O 方面是否出现问题</li><li>进程 kswapd 是负责确保闲置内存可被释放，每次启动扫描会尝试释放 32 个 pages，并且一直在重复这个程序直到限制内存数值高于 pages_high（核心参数）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析-Android-Performance-问题&quot;&gt;&lt;a href=&quot;#分析-Android-Performance-问题&quot; class=&quot;headerlink&quot; title=&quot;分析 Android Performance 问题&quot;&gt;&lt;/a&gt;分析 Android </summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 音频系统</title>
    <link href="http://example.com/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-10T02:37:51.000Z</published>
    <updated>2022-06-30T01:20:01.577Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>App<br>音频应用软件</p></li><li><p>Framework<br>MediaPlayer 和 MediaRecorder，以及 AudioTrack、AudioRecorder、AudioMannager、AudioService 以及 AudioSystem。</p></li><li><p>Libraries<br>frameorks/av/media/libmedia、libaudioflinger、libmediaplayerservice</p></li><li><p>HAL<br>AudioFlinger、AudioPolicyService。</p></li></ul><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-57-07.png"></p><ul><li><p>AudioPolicyService：APS 是音频框架的服务，main_audioserver 启动，会创建 AudioCommandThread 和 AudioPolicyClient、AudioPolicyManager。它主要由 AudioSystem 通过 binder 调用，也可以由 AudioPolicyClient，AudioPolicyManager 直接调用。它的大部分操作都交给 AudioPolicyManager 来做</p></li><li><p>AudioPolicyClient：APC 是 AudioPolicyService 的内部类。它用于打开关闭输入输出，设置流音量，传递参数给 hal 层（如 audio_hw.cpp）等；它主要是通过 binder 跨进程调用 AudioFlinger 去完成真正的操作。可以由 AudioManager 通过 mpClientInterface 去调用它。</p></li><li><p>AudioPolicyManager：APM 是 AudioPolicyService 的主要工作类，AudioPolicyService 的大部分操作都由他来执行</p></li><li><p>AudioFlinger：AF 主要承担音频混合输出，是 Audio 系统的核心，从 AudioTrack 来的数据最终都会在这里处理，并被写入到 Audio 的 HAL。</p></li><li><p>DevicesFactoryHalLocal：根据名字加载对应的 hal module。比如传进去 a2dp 相关的名字，会加载到 audio.a2dp.default.so</p></li><li><p>DevicesFactoryHalHidl：跨进行加载 hidl hal module。</p></li><li><p>DevicesFactoryHalInterface：用于创建子类 DevicesFactoryHalHybrid。</p></li><li><p>DevicesFactoryHalHybrid：选择创建 DevicesFactoryHalLocal 或者 DevicesFactoryHalHidl，我这里只创建 DevicesFactoryHalLocal。</p></li><li><p>DeviceHalLocal：通过私有成员 audio_hw_device_t *mDev，直接调用 hal 代码，用来设置和获取底层参数，打开和关闭 stream。</p></li><li><p>StreamOutHalLocal：通过私有成员 audio_stream_out_t *mStream 直接调用 hal 代码，用于操作流，比如 start、stop、flush、puse 操作；还有调用 write 函数写音频数据到 hal 层。</p></li><li><p>AudioStreamOutSink：它其实是 StreamOutHalLocal 的一个 wrapper，它也有 write 函数，不过是通过 StreamOutHalLocal 来操作的。</p><p>附上一张重要的类图：</p><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-57-45.png"></p></li></ul><h2 id="Audio-服务的启动"><a href="#Audio-服务的启动" class="headerlink" title="Audio 服务的启动"></a>Audio 服务的启动</h2><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-58-13.png"></p><ol><li>创建 AudioFlinger 和 AudioPolicyService。</li><li>解析 Audio Config 文件（audio_policy_configuration.xml），获取支持的音频外设列表及各输入输出通路详细参数。</li><li>根据解析得到的外设列表，加载所有的 Audio HAL 库。</li><li>为所有 output 设备打开 outputStream 并创建 PlaybackThread 线程。</li><li>为所有 input 设备打开 inputStream 并创建 RecordThread 线程。</li></ol><h2 id="AudioTrack"><a href="#AudioTrack" class="headerlink" title="AudioTrack"></a>AudioTrack</h2><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-58-33.png"></p><p>Android 声音播放都是通过 AudioTrack 进行，包括 MediaPlayer 最终也是创建 AudioTrack 来播放的。通过 AudioTrack 播放声音主要包括下面几步：</p><ol><li>创建 AudioTrack。</li><li>调用 AudioTrack 的 play() 方法。</li><li>调用 AudioTrack 的 write() 方法写入音频数据。</li></ol><p>创建 AudioTrack 时重点是通过 AudioPolicyManager 分配了音频路由通路，同时通知服务端 AudioFlinger 创建对应的 Track，用于接收音频数据。</p><ul><li>调用 play() 方法主要是将创建的 Track 加到 mActiveTracks 并激活沉睡的 PlaybackThread 线程。</li><li>调用 write() 方法通过共享内存将数据写入服务端 AudioFlinger，PlaybackThread 收到数据激活线程，将数据进行混音等处理再写入对应的 Audio HAL，Audio HAL 再将数据写入驱动或其它外设。</li></ul><h2 id="音频策略"><a href="#音频策略" class="headerlink" title="音频策略"></a>音频策略</h2><p>音频调试参考 <a href="https://source.android.com/devices/audio/debugging?hl=zh-cn">Android Audio</a>。</p><p>首先要搞清楚 stream_type，device，strategy 三者之间的关系：</p><ul><li>AudioSystem::stream_type：音频流的类型</li><li>AudioSystem::audio_devices：音频输入输出设备，每一个 bit 代表一种设备。</li><li>AudioPolicyManagerBase::routing_strategy：音频路由策略</li></ul><p>AudioPolicyManagerBase.getStrategy 根据 stream type，返回对应的 routing strategy 值，AudioPolicyManagerBase.getDeviceForStrategy() 则是根据 routing strategy，返回可用的 device。<br>首先需要的是加载音频设备，音频设备的配置在 <code>system/etc/audio_policy.conf</code> 和 <code>vendor/etc/aduio_policy</code>, 配置文件中表示了各种 audio interface，通过 AudioFlinger 加载音频设备。<br>按照一定的优先级选择符合要求的 Device，然后为 Device 选择合适的 Output 通道。<br>可以通过重载 getStrategy 自己划分 Strategy。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">routing_strategy strategy = (routing_strategy) <span class="built_in">getStrategyForAttr</span>(&amp;attributes);</span><br><span class="line"><span class="keyword">audio_devices_t</span> device = <span class="built_in">getDeviceForStrategy</span>(strategy, <span class="literal">false</span> <span class="comment">/*fromCache*/</span>);</span><br></pre></td></tr></table></figure><h2 id="截取音频数据"><a href="#截取音频数据" class="headerlink" title="截取音频数据"></a>截取音频数据</h2><p>有三个地方可以获取到 PCM 数据：</p><ul><li>第一个地方 <code>frameworks/av/media/libmedia/AudioTrack.cpp</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">nsecs_t</span> <span class="title">AudioTrack::processAudioBuffer</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在 releaseBuffer 之前 dump </span></span><br><span class="line"><span class="built_in">releaseBuffer</span>(&amp;audioBuffer);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>第二个地方 <code>frameworks/av/services/audioflinger/Tracks.cpp</code></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AudioFlinger::PlaybackThread::Track::<span class="built_in">getNextBuffer</span>(</span><br><span class="line">        AudioBufferProvider::Buffer* buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// add dump method</span></span><br><span class="line">    ServerProxy::Buffer buf;</span><br><span class="line">    <span class="keyword">size_t</span> desiredFrames = buffer-&gt;frameCount;</span><br><span class="line">    buf.mFrameCount = desiredFrames;</span><br><span class="line">    <span class="keyword">status_t</span> status = mServerProxy-&gt;<span class="built_in">obtainBuffer</span>(&amp;buf);</span><br><span class="line">    buffer-&gt;frameCount = buf.mFrameCount;</span><br><span class="line">    buffer-&gt;raw = buf.mRaw;</span><br><span class="line">    <span class="keyword">if</span> (buf.mFrameCount == <span class="number">0</span> &amp;&amp; !<span class="built_in">isStopping</span>() &amp;&amp; !<span class="built_in">isStopped</span>() &amp;&amp; !<span class="built_in">isPaused</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;underrun,  framesReady(%zu) &lt; framesDesired(%zd), state: %d&quot;</span>,</span><br><span class="line">                buf.mFrameCount, desiredFrames, mState);</span><br><span class="line">        mAudioTrackServerProxy-&gt;<span class="built_in">tallyUnderrunFrames</span>(desiredFrames);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAudioTrackServerProxy-&gt;<span class="built_in">tallyUnderrunFrames</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三个地方<code>hardware/xxx/audio/tinyalsa_hal/audio_hw.c</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static ssize_t out_write(struct audio_stream_out *stream, const void* buffer, size_t bytes)</span><br><span class="line">&#123;  </span><br><span class="line">//add dump method </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="音频数据流向"><a href="#音频数据流向" class="headerlink" title="音频数据流向"></a>音频数据流向</h2><p>Android 系统 audio 框架中主要有三种播放模式：low latency playback、deep buffer playback 和 compressed offload playback。</p><ul><li>low latency / deep buffer 模式下的音频数据流向</li></ul><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-59-01.png"></p><ul><li>compressed offload 模式下的音频数据流向</li></ul><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-59-35.png"></p><ul><li><p>音频录制<br><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-21-59-56.png"></p></li><li><p>打电话<br><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-22-00-13.png"></p></li></ul><h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>module 下面有 mixPorts、devicePorts 和 routes 子段，它们下面又分别包含多个 mixPort、devicePort 和 route 的字段，这些字段内标识为 source 和 sink 两种角色：<br>devicePorts(source)：为实际的硬件输入设备；<br>devicePorts(sink)：为实际的硬件输出设备；<br>mixPorts(source)：为经过 AudioFlinger 之后的流类型，也称“输出流设备”，是个逻辑设备而非物理设备，对应 AudioFlinger 里面的一个 PlayerThread；<br>mixPorts(sink)：为进入 AudioFlinger 之前的流类型，也称“输入流设备”，是个逻辑设备而非物理设备，对应 AudioFlinger 里面的一个 RecordThread；<br>routes：定义 devicePort 和 mixPorts 的路由策略。</p><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-22-00-30.png"></p><p>profile 参数包含音频流一些信息，比如位数、采样率、通道数，它将被构建为 AudioProfile 对象，保存到 mixPort，然后在存储到 module。对于 xml 里面的 devicePort，一般没有 profile 参数，则会创建一个默认的 profile。当把 mixPort 加入到 Moudle 时，会进行分类：</p><p>即 source 角色保存到 OutputProfileCollection mOutputProfiles，sink 角色保存到 InputProfileCollection mInputProfiles。<br>而 devicePort 则调用 HwModule::setDeclaredDevices() 保存到 module 的 mDeclaredDevices。</p><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-22-00-49.png"></p><h2 id="HAL"><a href="#HAL" class="headerlink" title="HAL"></a>HAL</h2><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-22-01-05.png"></p><p>Audio HAL 大致的类图，hal 采用工厂模式，分为 Local 和 HIDL 模式，最后都会调用到 audio_stream_out 或者 audio_stream_in 中，对应调用到 audio_hw.c（由各个厂商实现）中。</p><h2 id="蓝牙连接例子"><a href="#蓝牙连接例子" class="headerlink" title="蓝牙连接例子"></a>蓝牙连接例子</h2><p><img src="/2022/03/10/Android%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F/2022-06-29-22-01-16.png"></p><p>AudioService 的 handleDeviceConnection 调用 AudioPolicyManager 的 setDeviceConnectionStateInt。</p><p>checkOutputsForDevice 会检测所有的 profile（output），查找每个 profile 是否都存在对应的线程，如果没有则进行创建 checkOutputForAllStrategies 切换 AudioTrack 的写入数据源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;App&lt;br&gt;音频应用软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Framework&lt;br&gt;MediaPlayer 和 MediaRecorder，以及 AudioTrack、AudioRecorder、AudioMannager、AudioService 以</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="系统" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android 图形系统</title>
    <link href="http://example.com/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-09T04:24:15.000Z</published>
    <updated>2022-06-30T03:44:49.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>官方简介：<a href="https://source.android.com/devices/graphics">Android-Graphics</a></p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-44-47.png" alt="2022-06-30-11-44-47"></p><ul><li><p>Image Stream Producers：图形生产者，用来生成图形缓冲区，以供图形消费者使用。例如OpenGL ES、Canvas 2D 和 mediaserver 视频解码器。</p></li><li><p>Native Framework：Libgui库，包含了图形系统底层的基本元素，例如Surface、BufferQueue、GraphicBufferConsumer、GraphicBufferProducer、SurfaceComposer等等。</p></li><li><p>Window Positioning：WindowManager，用来控制 window 对象，window为一组view对象的集合。它为 SurfaceFlinger 提供缓冲区和窗口元数据，而 SurfaceFlinger 可使用这些信息将 Surface 合成到屏幕。</p></li><li><p>Image Stream Consumers：图形消费者，包括 SurfaceFlinger 和一些图形应用。</p><ul><li>图形流的最常见消费者是 SurfaceFlinger，该系统服务会消耗当前可见的 Surface，并使用 WindowManager 中提供的信息将它们合成到显示部分。SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface。</li><li>一些 OpenGL ES 应用也可以做为消费者，例如相机应用会消费相机预览图像流。非 GL 应用也可以是消费者，例如 ImageReader 类。</li></ul></li><li><p>HAL：显示子系统的硬件抽象实现，包括 Hardware Composer 和 Gralloc。</p><ul><li>SurfaceFlinger 可以将某些合成工作委托给 Hardware Composer，以分担 OpenGL 和 GPU 上的工作量。这时，SurfaceFlinger 只是充当另一个 OpenGL ES 客户端，Hardware Composer 则进行图形渲染的工作。Hardware Composer 必须支持事件，其中之一是 VSYNC（另一个是支持即插即用 HDMI 的热插拔）。</li><li>Gralloc用来分配图形生产方请求的内存。</li></ul></li></ul><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-32-42.png" alt="2022-06-30-11-32-42"></p><h2 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h2><p>官方简介：<a href="https://source.android.com/devices/graphics/arch-bq-gralloc">Android-BufferQueue</a></p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-39-08.png" alt="2022-06-30-11-39-08"></p><p>左侧的对象是生成图形缓冲区的渲染器，如主屏幕、状态栏和系统界面。SurfaceFlinger 是合成器，而 Hardware Composer 是制作器。BufferQueue 是 Android 图形系统很重要的组成部分，它负责数据的传递：</p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-39-36.png" alt="2022-06-30-11-39-36"></p><p>图中的 producer 和 consumer 运行在不同的进程里，BufferQueue 是将缓冲区池与队列相结合的数据结构，它使用 Binder IPC 在进程之间传递缓冲区。几个重要函数如下：</p><ul><li>producers 通过 BufferQueue 请求一块空闲的缓存区(GraphicBuffer): IGraphicBufferProducer.dequeueBuffer 方法</li><li>往缓存区(GraphicBuffer)填充了数据(绘制等)后, producers 将缓存区(GraphicBuffer)入队列到 BufferQueue 中: IGraphicBufferProducer.queueBuffer 方法</li><li>consumer 从 BufferQueue 中出队列一块缓存区(GraphicBuffer): IGraphicBufferConsumer.acquireBuffer 方法</li><li>consumer 消费完毕后(典型的是 SurfaceFlinger 合成数据)将缓存区(GraphicBuffer)返回给队列: IGraphicBufferConsumer.releaseBuffer 方法</li></ul><p>其中 IGraphicBufferProducer 是 BufferQueue 的生产者接口，实现类是 BufferQueueProducer 生产者类；IGraphicBufferConsumer 是 BufferQueue 的消费者接口，实现类是 BufferQueueConsumer 消费者类。</p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-39-58.png" alt="2022-06-30-11-39-58"></p><h2 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h2><p>SurfaceFlinger 用来管理消费当前可见的 Surface, 所有被渲染的可见 Surface 都会被 SurfaceFlinger 通过 WindowManager 提供的信息合成(使用 OpenGL 和 HardWare Composer)提交到屏幕的后缓冲区，等待屏幕的下一个 Vsync 信号到来，再显示到屏幕上。SufaceFlinger 通过屏幕后缓冲区与屏幕建立联系，同时通过 Surface 与上层建立联系，起到了一个承上启下的作用。</p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-40-23.png" alt="2022-06-30-11-40-23"></p><p>SurfaceFlinger工作流程</p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-40-40.png" alt="2022-06-30-11-40-40"></p><p>SurfaceFlinger的registerCallback时的<strong>this</strong>就是SurfaceFlinger对ComposerCallback接口的实现。</p><ul><li><p>onHotplugReceived</p><p>热插拔事件，显示屏幕连接或者断开时回调</p></li><li><p>onRefreshReceived</p><p>接收底层HWComposer的刷新请求，实现方法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onRefreshReceived</span><span class="params">(<span class="keyword">int</span> sequenceId,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">hwc2_display_t</span> <span class="comment">/*display*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sequenceId !=<span class="built_in">getBE</span>().mComposerSequenceId) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">repaintEverythingLocked</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::repaintEverythingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">android_atomic_or</span>(<span class="number">1</span>, &amp;mRepaintEverything);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发刷新，重新合成显示</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">signalTransaction</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>onVsyncReceived</p><p>Vsync事件上报，接收底层硬件上报的垂直同步信号。</p></li></ul><p>为什么需要垂直同步信号，参考<a href="https://juejin.cn/post/6863756420380196877#heading-1">https://juejin.cn/post/6863756420380196877#heading-1</a></p><h3 id="合成方式"><a href="#合成方式" class="headerlink" title="合成方式"></a>合成方式</h3><ul><li>Client合成</li></ul><p>将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件，Client合成，采用RenderEngine进行合成</p><ul><li>Device合成</li></ul><p>硬件合成器进行合成HWComposer，其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据</p><h4 id="HWC相关图表"><a href="#HWC相关图表" class="headerlink" title="HWC相关图表"></a>HWC相关图表</h4><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-41-18.png" alt="2022-06-30-11-41-18"></p><h4 id="合成图表"><a href="#合成图表" class="headerlink" title="合成图表"></a>合成图表</h4><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-41-30.png" alt="2022-06-30-11-41-30"></p><h3 id="Dump信息"><a href="#Dump信息" class="headerlink" title="Dump信息"></a>Dump信息</h3><p><code>adb shell dumpsys SurfaceFlinger</code></p><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-41-46.png" alt="2022-06-30-11-41-46"></p><h3 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h3><p>图层（Layer）是合成的最重要单元；每个图层都有一组属性，用于定义它与其他层的交互方式。Layer在每一层中的代码的实现不一样，基本上Laye的理念都是一样的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">frameworks/native/services/surfaceflinger</span><br><span class="line"></span><br><span class="line">├── Layer.h</span><br><span class="line"></span><br><span class="line">├── Layer.cpp</span><br><span class="line"></span><br><span class="line">├── ColorLayer.h</span><br><span class="line"></span><br><span class="line">├── ColorLayer.cpp</span><br><span class="line"></span><br><span class="line">├── BufferLayer.h</span><br><span class="line"></span><br><span class="line">└── BufferLayer.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个图形显示系统可以简单地分为图形和显示两个系统理解。</p><ul><li>图形系统，提供绘图和图形处理的支持。无论是2D的Skia，还是3D的OpenGLES，还有各种图片解吗库</li><li>显示系统，图形绘制好后，需要显示，就需要合并窗口，这个时候就需要用到Surfaceflinger，上层的显示系统有View、ActivityManagerService和WindowManagerService组成。一个窗口就是一个Surface，Surfacedlinger使用Layer去描述一个窗口。</li></ul><p><img src="/2022/01/09/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/2022-06-30-11-42-11.png" alt="2022-06-30-11-42-11"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;官方简介：&lt;a href=&quot;https://source.android.com/devices/graphics&quot;&gt;Android-Gra</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="系统" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>图像与视频</title>
    <link href="http://example.com/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/"/>
    <id>http://example.com/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/</id>
    <published>2021-05-07T11:19:32.000Z</published>
    <updated>2022-06-30T01:20:01.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像编码"><a href="#图像编码" class="headerlink" title="图像编码"></a>图像编码</h2><p>一张图片可以使用一个二维矩阵表示，矩阵中的每一个点被称为像素。每个像素的颜色使用三原色来表示，即红、绿、蓝。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-52-46.png"></p><p>每个像素可以用不同的数据位数来表示，常用的量化位数有 16 位、24 位、32 位等。</p><ul><li>24 位比特模式：每像素 24 位（bits per pixel，bpp）编码的 RGB 值：使用三个 8 位无符号整数（0 到 255）表示红色、绿色和蓝色的强度。</li><li>16 位比特模式：分配给每种原色各为 5 比特，其中绿色为 6 比特，因为人眼对绿色分辨的色调更精确。但某些情况下每种原色各占 5 比特，余下的 1 比特不使用。</li><li>32 位比特模式：同 24 位比特模式，余下的 8 比特用来表示象素的透明度（Alpha）。</li></ul><p>图片还有一个很重要的属性就是分辨率，采用宽 x 高表示。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-53-03.png"></p><p>在处理图像或视频时另一个属性是长宽比，它描述了图像或像素的宽度和高度之间的比例关系。常见的比例有 4:3、16:9、21:9，通常指显示宽高比（DAR），同样像素也有不同的宽高比，称之为像素长宽比（PAR）。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-53-18.png"></p><h2 id="YUV-颜色模型"><a href="#YUV-颜色模型" class="headerlink" title="YUV 颜色模型"></a>YUV 颜色模型</h2><p>RGB 诉求于人眼对色彩的感应，YUV 则着重于视觉对于亮度的敏感程度，Y 代表的是亮度（Luminance、Luma），UV 代表的是色度（Chrominance/Chroma）（因此黑白电影可省略 UV，相近于 RGB），分别用 Cr 和 Cb 来表示，因此 YUV 的记录通常以 Y:UV 的格式呈现。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-05-04.png"></p><p>为节省带宽起见，大多数 YUV 格式平均使用的每像素位数都少于 24 位。主要的抽样（subsample）格式有 YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1 和 YCbCr 4:4:4。YUV 的表示法称为 A:B:C 表示法：</p><ul><li>4:4:4 表示完全取样。</li><li>4:2:2 表示 2:1 的水平取样，垂直完全采样。</li><li>4:2:0 表示 2:1 的水平取样，垂直 2:1 采样。</li><li>4:1:1 表示 4:1 的水平取样，垂直完全采样。</li></ul><h3 id="RGB-与-YUV-的转换"><a href="#RGB-与-YUV-的转换" class="headerlink" title="RGB 与 YUV 的转换"></a>RGB 与 YUV 的转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 第一步计算亮度</span><br><span class="line">Y = <span class="number">0.299</span>R + <span class="number">0.587</span>G + <span class="number">0.114B</span></span><br><span class="line"># 一旦有了亮度，可以分割颜色（色度蓝色和红色）：</span><br><span class="line">Cb = <span class="number">0.564</span>(B - Y)</span><br><span class="line">Cr = <span class="number">0.713</span>(R - Y)</span><br><span class="line"># 也可以通过使用 YCbCr 进行转换，甚至获得 RGB</span><br><span class="line">R = Y + <span class="number">1.402</span>Cr</span><br><span class="line">B = Y + <span class="number">1.772</span>Cb</span><br><span class="line">G = Y - <span class="number">0.344</span>Cb - <span class="number">0.714</span>Cr</span><br></pre></td></tr></table></figure><h2 id="采样率、码率、帧以及场的概念"><a href="#采样率、码率、帧以及场的概念" class="headerlink" title="采样率、码率、帧以及场的概念"></a>采样率、码率、帧以及场的概念</h2><p>图像则是对模拟信号进行采样量化后获得，而视频则是由一系列的图像组成，采集时图像的分辨率及量化位数越高，所能表达的信息越多，画面则越清晰。视频存在一个采样频率的属性，即单位时间内采样的次数。视频的采样频率也受人眼的限制，通常在每秒 20 ~ 30 帧之间。当采样频率在每秒 10<del>20 帧时，对于快速运动的图像，人眼可以感觉到不流畅，而采样频率提高到 20</del>30 帧时，人眼看起来比较流畅了。如果将采样频率在提高，人眼是很难感觉这种差异的，这也是目前电影拍摄时使用 24 帧或者 30 帧采样频率的原因。</p><p>显示视频所需要的每秒位数称作为比特率，也叫码率。计算公式为 <code>比特率=宽 高 位深度 每秒帧数</code>* 例如，如果我们不采用任何类型的压缩，每秒 30 帧，每像素 24 位，480x240 分辨率的视频将需要 82,944,000 位/秒 或 82.944 Mbps（30x480x240x24）。</p><p>当比特率几乎恒定时，称为恒定比特率（CBR），但它也可以变化，然后称为可变比特率（VBR）。下图显示了一个受限的 VBR，在帧为黑色时不会花太多位。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-05-19.png"></p><p>视频采样中通过逐行扫描得到一幅完整的图像称之为一帧，通常帧频率为 25 帧（PAL 制）、30 帧每秒（NTSC 制），而通过隔行扫描（奇、偶数行），那么一帧图像就被分成两场，通常场频为 50Hz（PAL 制）、60Hz（NTSC 制）。这是在早起，工程师们提出的一种技术，能够在不消耗额外的带宽的情况下，使得显示器的感知帧率倍增。这种技术称为隔行视频；它基本上在 1 帧中发送一半的屏幕，而在下一帧中发送另一半。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-05-52.png"></p><h2 id="H264-简介"><a href="#H264-简介" class="headerlink" title="H264 简介"></a>H264 简介</h2><blockquote><p>H264 是属于视频的编码层的标准格式，视频编码显然是为了压缩大小。</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>SODB：数据比特串 -&gt; 最原始的编码数据</li><li>RBSP：原始字节序列载荷 -&gt; 在 SODB 的后面填加了结尾比特（RBSP trailing bits 一个 bit“1”）若干比特“0”，以便字节对齐。</li><li>EBSP：扩展字节序列载荷 -&gt; 在 RBSP 基础上填加了仿校验字节（0X03）它的原因是：在 NALU 加到 Annexb 上时，需要填加每组 NALU 之前的开始码 StartCodePrefix，如果该 NALU 对应的 slice 为一帧的开始则用 4 位字节表示，0x00000001，否则用 3 位字节表示 0x000001，为了使 NALU 主体中不包括与开始码相冲突的，在编码时，每遇到两个字节连续为 0，就插入一个字节的 0x03。解码时将 0x03 去掉，也称为脱壳操作。</li></ul><blockquote><p>H.264 的功能分为两层，视频编码层（VCL）和网络提取层（NAL）</p></blockquote><p>VCL 数据即被压缩编码后的视频数据序列。在 VCL 数据要封装到 NAL 单元中之后，才可以用来传输或存储。<br><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-06-08.png"></p><p>H.264 的编码视频序列包括一系列的 NAL 单元，每个 NAL 单元包含一个 RBSP，见表 1。编码片（包括数据分割片 IDR 片）和序列 RBSP 结束符被定义为 VCL NAL 单元，其余为 NAL 单元。典型的 RBSP 单元序列如图 2 所示。</p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-06-19.png"></p><p>每个单元都按独立的 NAL 单元传送。单元的信息头（一个字节）定义了 RBSP 单元的类型，NAL 单元的其余部分为 RBSP 数据。</p><h3 id="NAL-单元"><a href="#NAL-单元" class="headerlink" title="NAL 单元"></a>NAL 单元</h3><blockquote><p>每个 NAL 单元是一个一定语法元素的可变长字节字符串，包括包含一个字节的头信息（用来表示数据类型），以及若干整数字节的负荷数据。一个 NAL 单元可以携带一个编码片、A/B/C 型数据分割或一个序列或图像参数集。</p></blockquote><p>NALU 头由一个字节组成，它的语法如下：</p><p>NAL 单元按 RTP 序列号按序传送。其中，T 为负荷数据类型，占 5 bit；R 为重要性指示位，占 2 个 bit；最后的 F 为禁止位，占 1 bit。具体如下：<br><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-06-37.png"></p><ol><li>NALU 类型位可以表示 NALU 的 32 种不同类型特征，类型 1～12 是 H.264 定义的，类型 24～31 是用于 H.264 以外的，RTP 负荷规范使用这其中的一些值来定义包聚合和分裂，其他值为 H.264 保留。 </li><li>重要性指示位用于在重构过程中标记一个 NAL 单元的重要性，值越大，越重要。值为 0 表示这个 NAL 单元没有用于预测，因此可被解码器抛弃而不会有错误扩散；值高于 0 表示此 NAL 单元要用于无漂移重构，且值越高，对此 NAL 单元丢失的影响越大。 </li><li>禁止位 编码中默认值为 0，当网络识别此单元中存在比特错误时，可将其设为 1，以便接收方丢掉该单元，主要用于适应不同种类的网络环境（比如有线无线相结合的环境）。</li></ol><p>264 常见的帧头数据为：</p><ul><li>00 00 00 01 <strong>67</strong> (SPS)</li><li>00 00 00 01 <strong>68</strong> (PPS)</li><li>00 00 00 01 <strong>65</strong> (IDR 帧）</li><li>00 00 00 01 <strong>61</strong> (P 帧）</li></ul><p>上述的 67、68、65、61，还有 41 等，都是该 NALU 的识别级别。</p><p>F：禁止为，0 表示正常，1 表示错误，一般都是 0</p><p>NRI：重要级别，11 表示非常重要。</p><p>TYPE：表示该 NALU 的类型是什么，</p><p>见下表，由此可知 7 为序列参数集（SPS），8 为图像参数集（PPS），5 代表 I 帧。1 代表非 I 帧。</p><p>​</p><p>由此可知，61 和 41 其实都是 P 帧（type 值为 1），只是重要级别不一样（它们的 NRI 一个是 11 BIN，一个是 10 BIN）</p><h3 id="H264-NAL-简介与-I-帧判断）"><a href="#H264-NAL-简介与-I-帧判断）" class="headerlink" title="H264 (NAL 简介与 I 帧判断）"></a>H264 (NAL 简介与 I 帧判断）</h3><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-07-18.png"></p><p>我们还是接着看最上面图的码流对应的数据来层层分析，以 00 00 00 01 分割之后的下一个字节就是 NALU 类型，将其转为二进制数据后，</p><p>解读顺序为从左往右算，如下：<br>（1）第 1 位禁止位，值为 1 表示语法出错</p><p>（2）第 2~3 位为参考级别</p><p>（3）第 4~8 为是 nal 单元类型</p><p>例如上面 00000001 后有 67、68 以及 65</p><p>其中 0x67 的二进制码为：</p><p>0110 0111</p><p>4-8 为 00111，转为十进制 7，参考第二幅图：7 对应序列参数集 SPS</p><p>其中 0x68 的二进制码为：</p><p>0110 1000 4-8 为 01000，转为十进制 8，参考第二幅图：8 对应图像参数集 PPS</p><p>其中 0x65 的二进制码为：</p><p>011 00101</p><p>4-8 位为 00101，转为十进制 5，参考第二幅图：5 对应 IDR 图像中的片 (I 帧）</p><p><strong>所以判断是否为 I 帧的算法为：</strong></p><p>（NALU 类型 &amp; 0001 1111） = 5 即 (NALU 类型 &amp; 31) = 5 比如 0x65 &amp; 31 = 5</p><h2 id="RTP-打包发送-H264-之封包详解"><a href="#RTP-打包发送-H264-之封包详解" class="headerlink" title="RTP 打包发送 H264 之封包详解"></a>RTP 打包发送 H264 之封包详解</h2><blockquote><p>RFC3984 是 H.264 的 baseline 码流在 RTP 方式下传输的规范</p></blockquote><p><strong>H264 的码流结构</strong></p><p><img src="/2021/05/07/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91/2022-06-29-22-07-39.png"></p><h3 id="单个-NALU"><a href="#单个-NALU" class="headerlink" title="单个 NALU"></a>单个 NALU</h3><p>12 字节的 RTP 头后面的就是音视频数据，比较简单。一个封装单个 NAL 单元包到 RTP 的 NAL 单元流的 RTP 序号必须符合 NAL 单元的解码顺序。对于 NALU 的长度小于 MTU 大小的包，一般采用单一 NAL 单元模式。对于一个原始的 H.264 NALU 单元常由<code>[Start Code] [NALU Header] [NALU Payload]</code>三部分组成，其中 Start Code 用于标示这是一个 NALU 单元的开始，必须是“00 00 00 01”或“00 00 01”, NALU 头仅一个字节，其后都是 NALU 单元内容。<br>打包时去除“00 00 01”或“00 00 00 01”的开始码，把其他数据封包的 RTP 包即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|F|NRI|  type   |                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">|               Bytes 2..n of a Single NAL unit                 |</span><br><span class="line">|                                                               |</span><br><span class="line">|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               :...OPTIONAL RTP padding        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>如有一个 H.264 的 NALU 是这样的：<br><code>[00 00 00 01 67 42 A0 1E 23 56 0E 2F …]</code></p><p>这是一个序列参数集 NAL 单元。[00 00 00 01] 是四个字节的开始码，67 是 NALU 头，42 开始的数据是 NALU 内容。<br>封装成 RTP 包将如下：<br><code>[RTP Header] [67 42 A0 1E 23 56 0E 2F]</code></p><p>即只要去掉 4 个字节的开始码就可以了。</p><h3 id="包聚合"><a href="#包聚合" class="headerlink" title="包聚合"></a>包聚合</h3><p>当 NALU 的长度特别小时，可以把几个 NALU 单元封在一个 RTP 包中。<br>为了体现/应对有线网络和无线网络的 MTU 巨大差异，RTP 协议定义了包聚合策略：</p><ul><li>STAP-A：聚合的 NALU 时间戳都一样，无 DON（decoding order number）；</li><li>STAP-B：聚合的 NALU 时间戳都一样，有 DON；</li><li>MTAP16：聚合的 NALU 时间戳不同，时间戳差值用 16 bit 记录；</li><li>MTAP24：聚合的 NALU 时间戳不同，时间戳差值用 24 bit 记录；</li><li>包聚合时，RTP 的时间戳是所有 NALU 时间戳的最小值；</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|F|NRI|  Type   |                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+                                               |</span><br><span class="line">|                                                               |</span><br><span class="line">|             one or more aggregation units                     |</span><br><span class="line">|                                                               |</span><br><span class="line">|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               :...OPTIONAL RTP padding        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">Figure 3.  RTP payload format for aggregation packets</span><br></pre></td></tr></table></figure><p>STAP-A 示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          RTP Header                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|STAP-A NAL HDR |         NALU 1 Size           | NALU 1 HDR    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         NALU 1 Data                           |</span><br><span class="line">:                                                               :</span><br><span class="line">+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               | NALU 2 Size                   | NALU 2 HDR    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         NALU 2 Data                           |</span><br><span class="line">:                                                               :</span><br><span class="line">|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               :...OPTIONAL RTP padding        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">Figure 7.  An example of an RTP packet including an STAP-A</span><br><span class="line">containing two single-time aggregation units</span><br></pre></td></tr></table></figure><h3 id="FU-A-的分片格式"><a href="#FU-A-的分片格式" class="headerlink" title="FU-A 的分片格式"></a>FU-A 的分片格式</h3><p>数据比较大的 H264 视频包，被 RTP 分片发送。12 字节的 RTP 头后面跟随的就是 FU-A 分片：而当 NALU 的长度超过 MTU 时，就必须对 NALU 单元进行分片封包。也称为 Fragmentation Units (FUs).</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| FU indicator  |   FU header  |                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |</span><br><span class="line">|                                                               |</span><br><span class="line">|                         FU payload                            |</span><br><span class="line">|                                                               |</span><br><span class="line">|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                               :...OPTIONAL RTP padding        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">Figure 14.  RTP payload format for FU-A</span><br></pre></td></tr></table></figure><p><strong>FU indicator 有以下格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|0|1|2|3|4|5|6|7|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|F|NRI|  Type   |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure><p>FU 指示字节的类型域 Type=28 表示 FU-A。NRI 域的值必须根据分片 NAL 单元的 NRI 域的值设置。</p><p><strong>FU header 的格式如下：</strong></p><pre><code>+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|S|E|R|  Type   |+---------------+</code></pre><p>S: 1 bit 当设置成 1 表明这是 NALU 的首个 fragmnet。当跟随的 FU 荷载不是分片 NAL 单元荷载的开始，开始位设为 0。</p><p>E: 1 bit 当设置成 1 表明是 NALU 的最后一个 fragment，即，荷载的最后字节也是分片 NAL 单元的最后一个字节。当跟随的 FU 荷载不是分片 NAL 单元的最后分片，结束位设置为 0。</p><p>R: 1 bit 保留位必须设置为 0，接收者必须忽略该位。</p><p>Type: 5 bits<br>NAL 单元荷载类型定义见下表</p><p><strong>单元类型以及荷载结构总结</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Type   Packet      Type name                       </span><br><span class="line">  ---------------------------------------------------------</span><br><span class="line">  0      undefined                                    -</span><br><span class="line">  1-23   NAL unit    Single NAL unit packet per H.264  </span><br><span class="line">  24     STAP-A     Single-time aggregation packet    </span><br><span class="line">  25     STAP-B     Single-time aggregation packet    </span><br><span class="line">  26     MTAP16    Multi-time aggregation packet     </span><br><span class="line">  27     MTAP24    Multi-time aggregation packet     </span><br><span class="line">  28     FU-A      Fragmentation unit                </span><br><span class="line">  29     FU-B      Fragmentation unit                 </span><br><span class="line">  30-31  undefined                            </span><br></pre></td></tr></table></figure><p><strong>拆包和解包</strong></p><p><strong>拆包</strong>：当编码器在编码时需要将原有一个 NAL 按照 FU-A 进行分片，原有的 NAL 的单元头与分片后的 FU-A 的单元头有如下关系：</p><p><strong>原始的 NAL 头的前三位为 FU indicator 的前三位，原始的 NAL 头的后五位为 FU header 的后五位，</strong></p><p>FU indicator 与 FU header 的剩余位数根据实际情况决定。</p><p><strong>解包：</strong>当接收端收到 FU-A 的分片数据，需要将所有的分片包组合还原成原始的 NAl 包时，FU-A 的单元头与还原后的 NAL 的关系如下：</p><p>还原后的 NAL 头的八位是由 FU indicator 的前三位加 FU header 的后五位组成，即：</p><p><strong>nal_unit_type = (fu_indicator &amp; 0xe0) | (fu_header &amp; 0x1f)</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/leandromoreira/digital_video_introduction">视频技术介绍</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图像编码&quot;&gt;&lt;a href=&quot;#图像编码&quot; class=&quot;headerlink&quot; title=&quot;图像编码&quot;&gt;&lt;/a&gt;图像编码&lt;/h2&gt;&lt;p&gt;一张图片可以使用一个二维矩阵表示，矩阵中的每一个点被称为像素。每个像素的颜色使用三原色来表示，即红、绿、蓝。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="音视频" scheme="http://example.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="视频技术" scheme="http://example.com/tags/%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>RTSP</title>
    <link href="http://example.com/2019/08/10/RTSP/"/>
    <id>http://example.com/2019/08/10/RTSP/</id>
    <published>2019-08-10T07:37:46.000Z</published>
    <updated>2022-06-30T01:20:01.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RTSP-协议"><a href="#RTSP-协议" class="headerlink" title="RTSP 协议"></a>RTSP 协议</h2><blockquote><p>实时流协议（Real Time Streaming Protocol，RTSP）是一种网络应用协议，专为娱乐和通信系统的使用，以控制流媒体服务器。该协议用于创建和控制终端之间的媒体会话。媒体服务器的客户端发布 VCR 命令，例如播放，录制和暂停，以便于实时控制从服务器到客户端（视频点播）或从客户端到服务器（语音录音）的媒体流。是 TCP/IP 协议体系中的一个应用层协议，由哥伦比亚大学，网景和 RealNetworks 公司提交的 IETF RFC 标准。对应的 RFC 编号是 2326，可以在这里搜索 <a href="http://www.rfc-editor.org/search/rfc_search_detail.php">RFC Editor</a></p></blockquote><p>该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP 在体系结构上位于 RTP 和 RTCP 之上，它使用 TCP 或 RTP 完成数据传输。RTSP 被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。尽管有时<strong>可以把 RTSP 控制信息和媒体数据流交织在一起传送</strong>，但一般情况 RTSP 本身并不用于转送媒体流数据。媒体数据的传送可通过 RTP/RTCP 等协议来完成。</p><p>该协议用于 C/S 模型，是一个基于文本的协议，用于在客户端和服务器端建立和协商实时流会话。</p><h3 id="协议体系"><a href="#协议体系" class="headerlink" title="协议体系"></a>协议体系</h3><p><strong>一次基本的 RTSP 操作过程：</strong></p><ul><li>首先，客户端连接到流服务器并发送一个 RTSP 描述命令（DESCRIBE）。</li><li>流服务器通过一个 SDP 描述来进行反馈，反馈信息包括流数量、媒体类型等信息。</li><li>客户端再分析该 SDP 描述，并为会话中的每一个流发送一个 RTSP 建立命令（SETUP），RTSP 建立命令告诉服务器客户端用于接收媒体数据的端口。流媒体连接建立完成后，</li><li>客户端发送一个播放命令（PLAY），服务器就开始在 UDP 上传送媒体流（RTP 包）到客户端。在播放过程中客户端还可以向服务器发送命令来控制快进、快退和暂停等。</li><li>最后，客户端可发送一个终止命令（TERADOWN）来结束流媒体会话。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端-&gt;服务器：DESCRIBE</span><br><span class="line">服务器-&gt;客户端：200 OK (SDP)</span><br><span class="line">客户端-&gt;服务器：SETUP</span><br><span class="line">服务器-&gt;客户端：200 OK</span><br><span class="line">客户端-&gt;服务器：PLAY</span><br><span class="line">服务器-&gt;客户端：(RTP 包）</span><br></pre></td></tr></table></figure><h3 id="协议特点"><a href="#协议特点" class="headerlink" title="协议特点"></a>协议特点</h3><ul><li>可扩展性：新方法和参数很容易加入 RTSP。</li><li>易解析：RTSP 可由标准 HTTP 或 MIME 解析器解析。</li><li>安全：RTSP 使用网页安全机制。</li><li>独立于传输：RTSP 可使用不可靠数据报协议（EDP），可靠数据报协议（RDP）；如要实现应用级可靠，可使用可靠流协议。</li><li>多服务器支持：每个流可放在不同服务器上，用户端自动与不同服务器建立几个并发控制连接，媒体同步在传输层执行。</li><li>记录设备控制：协议可控制记录和回放设备。</li><li>流控与会议开始分离：仅要求会议初始化协议提供，或可用来创建惟一会议标识号。特殊情况下，可用 SI 或 H.323 来邀请服务器入会。</li><li>适合专业应用：通过 SMPTE 时标，RTSP 支持帧级精度，允许远程数字编辑。</li><li>演示描述中立：协议没强加特殊演示或元文件，可传送所用格式类型；然而，演示描述至少必须包括一个 RTSP URL。</li><li>代理友好：此处，RTSP 明智地采用 HTTP 观念，使现在结构都可重用。结构包括 Internet 内容选择平台（PICS）。由于在大多数情况下控制连续媒体需要服务器状态，RTSP 不仅仅向 HTFP 添加方法。</li><li>适当的服务器控制：如用户启动一个流，必须也可以停止一个流。</li><li>传输协调：实际处理连续媒体流前，用户可协调传输方法。</li><li>性能协调：如基本特征无效，必须有一些清理机制让用户决定哪种方法没生效。</li></ul><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><h3 id="RTSP-URL"><a href="#RTSP-URL" class="headerlink" title="RTSP URL"></a>RTSP URL</h3><p>一个终端用户是通过在播放器中输入 URL 地址开始进行观看流媒体业务的第一步，而对于使用 RTSP 协议的移动流媒体点播而言，URL 的一般写法如下：</p><p>一个以“rtsp”或是“rtspu”开始的 URL 链接用于指定当前使用的是 RTSP 协议。RTSP URL 的语法结构如下： <code>rtsp_url = (“rtsp:”| “rtspu:”) “//” host [“:”port”] /[abs_path]/content_name</code></p><ul><li>host：可以是一个有效的域名或是 IP 地址。</li><li>port：端口号，对于 RTSP 协议来说，缺省的端口号为 554。当我们在确认流媒体服务器提供的端口号为 554 时，此项可以省略。</li><li>abs_path：为 RTSP Server 中的媒体流资源标识，见下章节的录像资源命名。</li></ul><p>RTSP URL 用来标识 RTSP Server 的媒体流资源，可以标识单一的媒体流资源，也可以标识多个媒体流资源的集合。</p><h3 id="RTSP-报文"><a href="#RTSP-报文" class="headerlink" title="RTSP 报文"></a>RTSP 报文</h3><p>RTSP 是一种基于文本的协议，用 CRLF 作为一行的结束符。</p><p>RTSP 有两类报文：<strong>请求报文和响应报文</strong>。请求报文是指从客户向服务器发送请求报文，响应报文是指从服务器到客户的回答。由于 RTSP 是面向正文的（text-oriented），因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。RTSP 报文由三部分组成，即<strong>开始行、首部行和实体主体</strong>。在请求报文中，开始行就是请求行。</p><p>RTSP 请求报文的方法包括：OPTIONS、DESCRIBE、SETUP、TEARDOWN、PLAY、PAUSE、GET_PARAMETER 和 SET_PARAMETER。</p><p>一个请求消息（a request message）即可以由客户端向服务端发起也可以由服务端向客户端发起。请求消息的语法结构如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request = Request-Line</span><br><span class="line">(general-header|request-header|entity-header)</span><br><span class="line">CRLF</span><br><span class="line">[message-body]</span><br></pre></td></tr></table></figure><blockquote><p>Request Line</p></blockquote><p>请求消息的第一行的语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request-Line = Method 空格 Request-URI 空格 RTSP-Version CRLF</span><br></pre></td></tr></table></figure><p>其中在消息行中出现的第一个单词即是所使用的信令标志。目前已经有的信息标志如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method = “DESCRIBE” </span><br><span class="line">        | “ANNOUNCE”</span><br><span class="line">        | “GET_PARAMETER”</span><br><span class="line">        | “OPTIONS”</span><br><span class="line">        | “PAUSE”</span><br><span class="line">        | “PLAY”</span><br><span class="line">        | “RECORD”</span><br><span class="line">        | “REDIRECT”</span><br><span class="line">        | “SETUP”</span><br><span class="line">        | “SET_PARAMETER”</span><br><span class="line">        | “TEARDOWN”</span><br></pre></td></tr></table></figure><p>例子： <code>DESCRIBE rtsp://example.com/media.mp4 RTSP/1.0</code></p><blockquote><p>Request Header Fields</p></blockquote><p>在消息头中除了第一行的内容外，还有一些需求提供附加信息。其中有些是一定要的，后续我们会详细介绍经常用到的几个域的含义。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request-header = Accept</span><br><span class="line">    |Accept-Encoding</span><br><span class="line">    |Accept-Language</span><br><span class="line">    |Authorization</span><br><span class="line">    |From</span><br><span class="line">    |If-Modified-Since</span><br><span class="line">    |Range</span><br><span class="line">    |Referer</span><br><span class="line">    |User-Agent</span><br></pre></td></tr></table></figure><blockquote><p>响应消息</p></blockquote><p>响应消息的语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response = Status-Line </span><br><span class="line">(general-header |response-header|entity-header) </span><br><span class="line">CRLF </span><br><span class="line">[message-body]</span><br></pre></td></tr></table></figure><blockquote><p>Status-Line</p></blockquote><p>响应消息的第一行是状态行（status-line），每个元素之间用空格分开。除了最后的 CRLF 之外，在此行的中间不得有 CR 或是 LF 的出现。它的语法格式如下，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Status-Line = RTSP-Version 空格 Status-Code 空格 Reason-Phrase CRLF</span><br></pre></td></tr></table></figure><p>状态码（Status-Code）是一个三位数的整数，用于描述接收方对所收到请求消息的执行结果</p><p>Status-Code 的第一位数字指定了这个回复消息的种类，一共有 5 类：</p><ul><li>1XX：Informational – 请求被接收到，继续处理。</li><li>2XX：Success – 请求被成功的接收，解析并接受。</li><li>3XX：Redirection – 为完成请求需要更多的操作。</li><li>4XX：Client Error – 请求消息中包含语法错误或是不能够被有效执行。</li><li>5XX：Server Error – 服务器响应失败，无法处理正确的有效的请求消息。</li></ul><p>我们在处理问题时经常会遇到的状态码有如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Status-Code= “200&quot;: OK ,</span><br><span class="line">             “400”: Bad Request ,</span><br><span class="line">             “404”: Not Found ,</span><br><span class="line">             “500”: Internal Server Error</span><br></pre></td></tr></table></figure><blockquote><p>Response Header Fields</p></blockquote><p>在响应消息的域中存放的是无法放在 Status-Line 中，而又需要传送给请求者的一些附加信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response-header = Location</span><br><span class="line">Proxy-Authenticate</span><br><span class="line">Public</span><br><span class="line">Retry-After</span><br><span class="line">Server</span><br><span class="line">Vary</span><br><span class="line">WWW-Authenticate</span><br></pre></td></tr></table></figure><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><table><thead><tr><th align="left">方法</th><th align="left">方向</th><th align="left">对象</th><th>要求</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">DESCRIBE</td><td align="left">C-&gt;S</td><td align="left">P   S</td><td>推荐</td><td align="center">检查演示或媒体对象的描述，DESCRIBE 的答复 - 响应组成媒体 RTSP 初始阶段</td></tr><tr><td align="left">ANNOUNCE</td><td align="left">C-&gt;S   S-&gt;C</td><td align="left">P  S</td><td>可选</td><td align="center">URL 识别的对象发送给服务，反之，ANNOUNCE 实时更新连接描述。</td></tr><tr><td align="left">GET_PARAMETER</td><td align="left">C-&gt;S   S-&gt;C</td><td align="left">P  S</td><td>可选</td><td align="center">请求检查 RUL 指定的演示与媒体的参数值</td></tr><tr><td align="left">OPTIONS</td><td align="left">C-&gt;S   S-&gt;C</td><td align="left">P  S</td><td>要求</td><td align="center">可在任意时刻发出 OPTIONS 请求</td></tr><tr><td align="left">PAUSE</td><td align="left">C-&gt;S</td><td align="left">P  S</td><td>推荐</td><td align="center">PAUSE 请求引起流发送临时中断</td></tr><tr><td align="left">PLAY</td><td align="left">C-&gt;S</td><td align="left">P  S</td><td>要求</td><td align="center">PLAY 告诉服务器以 SETUP 指定的机制开始发送数据</td></tr><tr><td align="left">RECORD</td><td align="left">C-&gt;S</td><td align="left">P  S</td><td>可选</td><td align="center">该方法根据演示描述初始化媒体数据记录范围</td></tr><tr><td align="left">REDIRECT</td><td align="left">S-&gt;C</td><td align="left">P  S</td><td>可选</td><td align="center">重定向请求通知客户端连接到另一服务器地址</td></tr><tr><td align="left">SETUP</td><td align="left">C-&gt;S</td><td align="left">S</td><td>要求</td><td align="center">对 URL 的 SETUP 请求指定用于流媒体的传输机制</td></tr><tr><td align="left">SET_PARAMETER</td><td align="left">C-&gt;S   S-&gt;C</td><td align="left">P  S</td><td>可选</td><td align="center">请求设置演示或 URL 指定流的参数值</td></tr><tr><td align="left">TEARDOWN</td><td align="left">C-&gt;S</td><td align="left">P  S</td><td>要求</td><td align="center">TEARDOWN 请求停止给定 URL 流发送，释放相关资源</td></tr></tbody></table><p>注：P—演示，C—客户端，S—服务器，S（对象栏）—流</p><p>信令指的是在 Request-URI 中指定的需要被接收者完成的操作。信令（The method）大小写敏感，不能以字符”$”开始，并且一定要是一个标记符。</p><h2 id="RTSP-Header-参数"><a href="#RTSP-Header-参数" class="headerlink" title="RTSP Header 参数"></a>RTSP Header 参数</h2><ol><li>Accept：用于指定客户端可以接受的媒体描述信息类型。比如：<code>Accept: application/rtsl, application/sdp;level=2</code>。</li><li>Bandwidth：用于描述客户端可用的带宽值。</li><li>CSeq：指定了 RTSP 请求回应对的序列号，在每个请求或回应中都必须包括这个头字段。对每个包含一个给定序列号的请求消息，都会有一个相同序列号的回应消息。</li><li>Range：用于指定一个时间范围，可以使用 SMPTE、NTP 或 clock 时间单元。</li><li>Session：Session 头字段标识了一个 RTSP 会话。Session ID 是由服务器在 SETUP 的回应中选择的，客户端一当得到 Session ID 后，在以后的对 Session 的操作请求消息中都要包含 Session ID。</li><li>Transport: Transport 头字段包含客户端可以接受的转输选项列表，包括传输协议，地址端口，TTL 等。服务器端也通过这个头字段返回实际选择的具体选项。如：<code>Transport:RTP/AVP;multicast;ttl=127;mode=&quot;PLAY&quot;</code>, <code>RTP/AVP;unicast;client_port=1289-1290;mode=&quot;PLAY&quot;</code></li></ol><h2 id="简单的-RTSP-消息交互过程"><a href="#简单的-RTSP-消息交互过程" class="headerlink" title="简单的 RTSP 消息交互过程"></a>简单的 RTSP 消息交互过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C 表示 RTSP 客户端，S 表示 RTSP 服务端</span><br><span class="line">第一步：查询服务器端可用方法 </span><br><span class="line">C-&gt;S OPTION request  询问 S 有哪些方法可用</span><br><span class="line">S-&gt;C OPTION response S 回应信息的 public 头字段中包括提供的所有可用方法</span><br><span class="line">第二步：得到媒体描述信息 </span><br><span class="line">C-&gt;S DESCRIBE request  要求得到 S 提供的媒体描述信息</span><br><span class="line">S-&gt;C DESCRIBE response  S 回应媒体描述信息一般是 sdp 信息</span><br><span class="line">第三步：建立 RTSP 会话 </span><br><span class="line">C-&gt;S SETUP request Transport 头字段列出可接受的传输选项，请求 S 建立会话</span><br><span class="line">S-&gt;C SETUP response S 建立会话通过 Transport 头字段返回选择的具体转输选项，并返回建立的 Session ID</span><br><span class="line">第四步：请求开始传送数据</span><br><span class="line">C-&gt;S PLAY request C 请求 S 开始发送数据</span><br><span class="line">S-&gt;C PLAY responseS 回应该请求的信息</span><br><span class="line">第五步： 数据传送播放中 </span><br><span class="line">S-&gt;C 发送流媒体数据 通过 RTP 协议传送数据</span><br><span class="line">第六步：关闭会话，退出</span><br><span class="line">C-&gt;S EARDOWN request C 请求关闭会话</span><br><span class="line">S-&gt;C TEARDOWN response S 回应该请求</span><br></pre></td></tr></table></figure><p>上述的过程只是标准的、友好的 RTSP 流程，但实际的需求中并不一定按此过程。其中第三和第四步是必需的！第一步，只要服务器和客户端约定好有哪些方法可用，则 option 请求可以不要。第二步，如果我们有其他途径得到媒体初始化描述信息（比如 http 请求等等），则我们也不需要通过 RTSP 中的 describe 请求来完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RTSP-协议&quot;&gt;&lt;a href=&quot;#RTSP-协议&quot; class=&quot;headerlink&quot; title=&quot;RTSP 协议&quot;&gt;&lt;/a&gt;RTSP 协议&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;实时流协议（Real Time Streaming Protocol，RT</summary>
      
    
    
    
    <category term="音视频" scheme="http://example.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="流媒体协议" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>RTP</title>
    <link href="http://example.com/2019/07/29/RTP/"/>
    <id>http://example.com/2019/07/29/RTP/</id>
    <published>2019-07-29T09:45:43.000Z</published>
    <updated>2022-06-30T01:20:01.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RTP-协议介绍"><a href="#RTP-协议介绍" class="headerlink" title="RTP 协议介绍"></a>RTP 协议介绍</h2><p>实时传输协议 RTP（Real-time Transport Protocol）是一个网络传输协议，它是由 IETF 的多媒体传输工作小组 1996 年在 RFC 1889 中公布的，后在 RFC3550 中进行更新。</p><p>它作为因特网标准在 <a href="https://www.rfc-editor.org/rfc/rfc3550.txt"> RFC 3550 </a> 有详细说明。<br>RTP 协议详细说明了在互联网上传递音频和视频的标准数据包格式。它一开始被设计为一个多播协议，但后来被用在很多单播应用中。RTP 协议常用于流媒体系统（配合 RTSP 协议），视频会议和一键通（Push toTalk）系统（配合 H.323 或 SIP），使它成为 IP 电话产业的技术基础。RTP 协议和 RTP 控制协议 RTCP 一起使用，而且它是建立在用户数据报协议上的（UDP）。</p><h3 id="RTP-和-RTCP"><a href="#RTP-和-RTCP" class="headerlink" title="RTP 和 RTCP"></a>RTP 和 RTCP</h3><ul><li><p>数据传输协议 RTP 用于实时传输数据。该协议提供的信息包括：时间戳（用于同步）、序列号（用于丢包和重排序检测）、以及负载格式（用于说明数据的编码格式）。</p></li><li><p>控制协议 RTCP，用于 QoS 反馈和同步媒体流。相对于 RTP 来说，RTCP 所占的带宽非常小，通常只有 5%。</p></li></ul><h3 id="RTP-的优势"><a href="#RTP-的优势" class="headerlink" title="RTP 的优势"></a>RTP 的优势</h3><p>提到流媒体传输、视频监控、视频会议、语音电话（VOIP），都离不开 RTP 协议的应用，但是为什么要使用 RTP 来进行流媒体的传输呢？为什么一定要用 RTP？</p><p>像 TCP 这样的可靠传输协议，通过超时和重传机制来保证传输数据流中的每一个 bit 的正确性，但这样会使得无论从协议的实现还是传输的过程都变得非常的复杂。而且，当传输过程中有数据丢失的时候，由于对数据丢失的检测（超时检测）和重传，会数据流的传输被迫暂停和延时。</p><p>RTP 协议是一种基于 UDP 的传输协议，RTP 本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠 RTCP 提供这些服务。这样，对于那些丢失的数据包，不存在由于超时检测而带来的延时，同时，对于那些丢弃的包，也可以由上层根据其重要性来选择性的重传。</p><h3 id="RTP-的协议层次"><a href="#RTP-的协议层次" class="headerlink" title="RTP 的协议层次"></a>RTP 的协议层次</h3><p><strong>流媒体体系结构</strong></p><p>流媒体应用中典型的协议体系结构。</p><p><img src="/2019/07/29/RTP/2022-06-29-22-46-30.png"></p><p>从图中可以看出，RTP 被划分在传输层，它建立在 UDP 上。同 UDP 协议一样，为了实现其实时传输功能，RTP 也有固定的封装形式。RTP 用来为端到端的实时传输提供时间信息和流同步，但并不保证服务质量。服务质量由 RTCP 来提供。</p><h2 id="RTP-工作机制"><a href="#RTP-工作机制" class="headerlink" title="RTP 工作机制"></a>RTP 工作机制</h2><p>当应用程序建立一个 RTP 会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给 RTP 包，一个给 RTC P 包，使得 RTP/RTCP 数据能够正确发送。RTP 数据发向偶数的 UDP 端口，而对应的控制信号 RTCP 数据发向相邻的奇数 UDP 端口（偶数的 UDP 端口 + 1），这样就构成一个 UDP 端口对。RTP 的发送过程如下，接收过程则相反。</p><ol><li>RTP 协议从上层接收流媒体信息码流（如 H.263），封装成 RTP 数据包；RTCP 从上层接收控制信息，封装成 RTCP 控制包。</li><li>RTP 将 RTP 数据包发往 UDP 端口对中偶数端口；RTCP 将 RTCP 控制包发往 UDP 端口对中的奇数端口。</li></ol><p>RTP 分组只包含 RTP 数据，而控制是由 RTCP 协议提供。RTP 在 1025 到 65535 之间选择一个未使用的偶数 UDP 端口号，而在同一次会话中的 RTCP 则使用下一个奇数 UDP 端口号。端口号 5004 和 5005 分别用作 RTP 和 RTCP 的默认端口号。RTP 分组的首部格式如图 2 所示，其中前 12 个字节是必须的。</p><p><img src="/2019/07/29/RTP/2022-06-29-22-46-40.png"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>RTP 应当是应用层的一部分。在应用的发送端，开发者必须编写用 RTP 封装分组的程序代码，然后把 RTP 分组交给 UDP。在接收端，RTP 分组通过 UDP 接口进入应用层后，还要利用开发者编写的程序代码从 RTP 分组中把应用数据块提取出来。</p><h3 id="RTP-报文"><a href="#RTP-报文" class="headerlink" title="RTP 报文"></a>RTP 报文</h3><p>首先，我们看看 RTP 的包头。RTP 报文头格式（见 RFC3550 Page12）：</p><p><img src="/2019/07/29/RTP/2022-06-29-22-47-13.png"></p><ul><li>版本号（V）：2 比特，用来标志使用的 RTP 版本。</li><li>填充位（P）：1 比特，如果该位置位，则该 RTP 包的尾部就包含附加的填充字节。</li><li>扩展位（X）：1 比特，如果该位置位的话，RTP 固定头部后面就跟有一个扩展头部。</li><li>CSRC 计数器（CC）：4 比特，含有固定头部后面跟着的 CSRC 的数目。</li><li>标记位（M）：1 比特，该位的解释由配置文档（Profile）来承担。对于在 RTP 以最小的控制配置文件下在音频和视频会议下运行的音频流，标记位设置为 1，表示在一段静默期后发送的第一个数据包，否则设置为 0。</li><li>载荷类型（PayloadType）：7 比特，标识了 RTP 载荷的类型。</li><li>序列号（SN）：16 比特，每发送一个 RTP 数据包，序列号增加  1。接收端可以据此检测丢包和重建包序列。</li><li>时间戳（Timestamp）：2 比特，记录了该包中数据的第一个字节的采样时刻。</li><li>同步源标识符（SSRC）：32 比特，同步源就是指 RTP 包流的来源。在同一个 RTP 会话中不能有两个相同的 SSRC 值。该标识符是随机选取的 RFC1889 推荐了 MD5 随机算法。</li><li>贡献源列表（CSRC List）：0~15 项，每项 32 比特，用来标志对一个 RTP 混合器产生的新包有贡献的所有 RTP 包的源。由混合器将这些有贡献的 SSRC 标识符插入表中。SSRC 标识符都被列出来，以便接收端能正确指出交谈双方的身份。</li></ul><h4 id="RTP-扩展头结构"><a href="#RTP-扩展头结构" class="headerlink" title="RTP 扩展头结构"></a>RTP 扩展头结构</h4><p><img src="/2019/07/29/RTP/2022-06-29-22-47-30.png"></p><p>若 RTP 固定头中的扩展比特位置 1（注意：如果有 CSRC 列表，则在 CSRC 列表之后），则一个长度可变的头扩展部分被加到 RTP 固定头之后。头扩展包含 16 比特的长度域，指示扩展项中 32 比特字的个数，不包括 4 个字节扩展头（因此零是有效值）。</p><p>RTP 固定头之后只允许有一个头扩展。为允许多个互操作实现独立生成不同的头扩展，或某种特定实现有多种不同的头扩展，扩展项的前 16 比特用以识别标识符或参数。这 16 比特的格式由具体实现的上层协议定义。基本的 RTP 说明并不定义任何头扩展本身。</p><h2 id="RTP-会话"><a href="#RTP-会话" class="headerlink" title="RTP 会话"></a>RTP 会话</h2><p>当应用程序建立一个 RTP 会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给 RTP 包，一个给 RTCP 包，使得 RTP/RTCP 数据能够正确发送。RTP 数据发向偶数的 UDP 端口，而对应的控制信号 RTCP 数据发向相邻的奇数 UDP 端口（偶数的 UDP 端口 + 1），这样就构成一个 UDP 端口对。</p><h3 id="RTP-发送过程"><a href="#RTP-发送过程" class="headerlink" title="RTP 发送过程"></a>RTP 发送过程</h3><ol><li>RTP 协议从上层接收流媒体信息码流（如 H.263），封装成 RTP 数据包；RTCP 从上层接收控制信息，封装成 RTCP 控制包。</li><li>RTP 数据包发往 UDP 端口对中偶数端口；RTCP 将 RTCP 控制包发往 UDP 端口对中的接收端口。</li></ol><h2 id="RTP-profile-机制"><a href="#RTP-profile-机制" class="headerlink" title="RTP profile 机制"></a>RTP profile 机制</h2><p>RTP 为具体的应用提供了非常大的灵活性，它将传输协议与具体的应用环境、具体的控制策略分开，传输协议本身只提供完成实时传输的机制，开发者可以根据不同的应用环境，自主选择合适的配置环境、以及合适的控制策略。</p><p>这里所说的控制策略指的是你可以根据自己特定的应用需求，来实现特定的一些 RTCP 控制算法，比如前面提到的丢包的检测算法、丢包的重传策略、一些视频会议应用中的控制方案等等（这些策略我可能将在后续的文章中进行描述）。</p><p>对于上面说的合适的配置环境，主要是指 RTP 的相关配置和负载格式的定义。RTP 协议为了广泛地支持各种多媒体格式（如 H.264, MPEG-4, MJPEG, MPEG），没有在协议中体现出具体的应用配置，而是通过 profile 配置文件以及负载类型格式说明文件的形式来提供。对于任何一种特定的应用，RTP 定义了一个 profile 文件以及相关的负载格式说明。</p><h2 id="RTCP"><a href="#RTCP" class="headerlink" title="RTCP"></a>RTCP</h2><p>服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在 RTP 会话期间，各参与者周期性地传送 RTCP 包。RTCP 包中含有已发送的数据包的数量、丢失的数据包的数量等统计资料，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。RTP 和 RTCP 配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+---------------+---------------+-------------------------------+</span><br><span class="line">|V=2|P|   IC    |       PT      |             Length            |</span><br><span class="line">+---------------+---------------+-------------------------------+</span><br><span class="line">|                                                               |</span><br><span class="line">|                  Format-specific information                  |</span><br><span class="line">|                                                               |</span><br><span class="line">|                                       +-----------------------+</span><br><span class="line">|                                       |    Padding if P = 1   |</span><br><span class="line">+---------------------------------------+-----------------------+</span><br></pre></td></tr></table></figure><p>各个字段的含义为：</p><ul><li>版本号，固定为 2；</li><li>填充（Padding）标志位，1 表示有填充；</li><li>条目数量（Item Count，简称 IC），在 RTCP 包的内容是条目列表时，用来表明条目数量；其他情况可作为别的含义；</li><li>包类型（Packet Type，也简称 PT），rfc3550 定义了五种标准包类型，分别是 sender report (SR), receiver report (RR), source description (SDES), goodbye (BYE), application-specific message (APP)；</li><li>长度，包头之后的内容总长度，单位是四字节，允许为 0；</li></ul><p>RTCP 包不会单独的被传输，它需要打包在一起形成复合包（compound packets）进行传输。每一个复合包都会被一个底层的包封装（通常是 UDP/IP 包）用来传输。如果要对复合包进行加密，那么 RTCP 的包组的前缀通常是一个 32 位的随机数。复合包的结构如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                                                               |</span><br><span class="line">|                          IP header                            |</span><br><span class="line">|                                                               |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                                                               |</span><br><span class="line">|                          UDP header                           |</span><br><span class="line">|                                                               |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                  Random prefix (if encrypted)                 |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|V=2|P|   IC    |       PT      |             Length            |</span><br><span class="line">+---------------+---------------+-------------------------------+</span><br><span class="line">|                                                               | first</span><br><span class="line">|                                                               | RTCP</span><br><span class="line">|                  Format-specific information                  | packet</span><br><span class="line">|                                                               |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|V=2|P|   IC    |       PT      |             Length            |</span><br><span class="line">+---------------+---------------+-------------------------------+</span><br><span class="line">|                                                               | second</span><br><span class="line">|                                                               | RTCP</span><br><span class="line">|                  Format-specific information                  | packet</span><br><span class="line">|                                                               |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>RTCP 也是用 UDP 来传送的，但 RTCP 封装的仅仅是一些控制信息，因而分组很短，所以可以将多个 RTCP 分组封装在一个 UDP 包中。RTCP 有如下五种分组类型。</p><table><thead><tr><th align="center">类型</th><th align="center">缩写表示</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">SR(Sender  Report)</td><td align="center">发送端报告</td></tr><tr><td align="center">201</td><td align="center">RR(Receiver Report)</td><td align="center">接收端报告</td></tr><tr><td align="center">202</td><td align="center">SDES(Source Description Items)</td><td align="center">源点描述</td></tr><tr><td align="center">203</td><td align="center">BYE</td><td align="center">结束传输</td></tr><tr><td align="center">204</td><td align="center">.APP</td><td align="center">特定应用</td></tr></tbody></table><p>上述五种分组的封装大同小异，下面只讲述 SR 类型，而其它类型请参考 RFC3550。</p><p>发送端报告分组 SR（Sender Report）用来使发送端以多播方式向所有接收端报告发送情况。SR 分组的主要内容有：相应的 RTP 流的 SSRC，RTP 流中最新产生的 RTP 分组的时间戳和 NTP，RTP 流包含的分组数，RTP 流包含的字节数。SR 包的封装如图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|    RC   |   PT=SR=200   |             Length            |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                     SSRC of packet sender                     |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                        NTP timestamp                          |</span><br><span class="line">|                                                               |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                        RTP timestamp                          |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                    Sender&#x27;s packet count                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                    Sender&#x27;s octet count                       |</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                   Receiver report block(s)                    |</span><br><span class="line">|                                                               |</span><br></pre></td></tr></table></figure><ul><li>版本（V）：同 RTP 包头域。</li><li>填充（P）：同 RTP 包头域。</li><li>接收报告计数器（RC）：5 比特，该 SR 包中的接收报告块的数目，可以为零。 </li><li>包类型（PT）：8 比特，SR 包是 200。</li><li>长度域（Length）：16 比特，其中存放的是该 SR 包以 32 比特为单位的总长度减一。</li><li>同步源（SSRC）：SR 包发送者的同步源标识符。与对应 RTP 包中的 SSRC 一样。 </li><li>NTP Timestamp（Network time protocol）：SR 包发送时的绝对时间值。NTP 的作用是同步不同的 RTP 媒体流。</li><li>RTP Timestamp：与 NTP 时间戳对应，与 RTP 数据包中的 RTP 时间戳具有相同的单位和随机初始值。</li><li>Sender’s packet count：从开始发送包到产生这个 SR 包这段时间里，发送者发送的 RTP 数据包的总数。SSRC 改变时，这个域清零。</li><li>Sender’s octet count：从开始发送包到产生这个 SR 包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其 SSRC 时，这个域要清零。</li><li>同步源 n 的 SSRC 标识符：该报告块中包含的是从该源接收到的包的统计信息。</li><li>丢失率 (Fraction Lost)：表明从上一个 SR 或 RR 包发出以来从同步源 n(SSRC_n) 来的 RTP 数据包的丢失率。</li><li>累计的包丢失数目：从开始接收到 SSRC_n 的包到发送 SR, 从 SSRC_n 传过来的 RTP 数据包的丢失总数。</li><li>收到的扩展最大序列号：从 SSRC_n 收到的 RTP 数据包中最大的序列号，</li><li>接收抖动 (Interarrival jitter)：RTP 数据包接受时间的统计方差估计</li><li>上次 SR 时间戳 (Last SR,LSR)：取最近从 SSRC_n 收到的 SR 包中的 NTP 时间戳的中间 32 比特。如果目前还没收到 SR 包，则该域清零。</li><li>上次 SR 以来的延时 (Delay since last SR,DLSR)：上次从 SSRC_n 收到 SR 包到发送本报告的延时。</li></ul><h2 id="RTP-时间戳"><a href="#RTP-时间戳" class="headerlink" title="RTP 时间戳"></a>RTP 时间戳</h2><p>时间戳反映了 RTP 分组中的数据的第一个字节的采样时刻，在一次会话开始时的时间戳初值也是随机选择的。即使是没有信号发送时，时间戳的数值也要随时间不 断的增加。接收端使用时间戳可准确知道应当在什么时间还原哪一个数据块，从而消除传输中的抖动。时间戳还可用来使视频应用中声音和图像同步。</p><p>在 RTP 协议中并没有规定时间戳的粒度，这取决于有效载荷的类型，如采样频率为 90000 HZ，那么时间戳单位为 1/90000, 如果每秒发送 30 帧，那么时间戳增量就是 90000/30 = 3000。</p><p>时间戳增量是发送第二个 RTP 包相距发送第一个 RTP 包时的时间间隔，如果是视频应该是发送每帧的间隔时间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>RTP header</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RTP header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0   <span class="comment">//BIG_ENDIA</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version:<span class="number">2</span>;   <span class="comment">/* protocol version */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">1</span>;         <span class="comment">/* padding flag */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x:<span class="number">1</span>;         <span class="comment">/* header extension flag */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cc:<span class="number">4</span>;        <span class="comment">/* CSRC count */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m:<span class="number">1</span>;         <span class="comment">/* marker bit */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pt:<span class="number">7</span>;        <span class="comment">/* payload type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq:<span class="number">16</span>;      <span class="comment">/* sequence number */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cc:<span class="number">4</span>;        <span class="comment">/* CSRC count */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x:<span class="number">1</span>;         <span class="comment">/* header extension flag */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">1</span>;         <span class="comment">/* padding flag */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version:<span class="number">2</span>;   <span class="comment">/* protocol version */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pt:<span class="number">7</span>;        <span class="comment">/* payload type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m:<span class="number">1</span>;         <span class="comment">/* marker bit */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seq:<span class="number">16</span>;      <span class="comment">/* sequence number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u_int32 ts;               <span class="comment">/* timestamp */</span></span><br><span class="line">    u_int32 ssrc;             <span class="comment">/* synchronization source */</span></span><br><span class="line">    u_int32 csrc[<span class="number">1</span>];          <span class="comment">/* optional CSRC list */</span></span><br><span class="line">&#125; <span class="keyword">rtp_hdr_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>RTCP Common header</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RTCP common header word</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0   <span class="comment">//BIG_ENDIA</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version:<span class="number">2</span>;   <span class="comment">/* protocol version */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">1</span>;         <span class="comment">/* padding flag */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count:<span class="number">5</span>;     <span class="comment">/* varies by packet type */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count:<span class="number">5</span>;     <span class="comment">/* varies by packet type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p:<span class="number">1</span>;         <span class="comment">/* padding flag */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version:<span class="number">2</span>;   <span class="comment">/* protocol version */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pt:<span class="number">8</span>;        <span class="comment">/* RTCP packet type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> length;           <span class="comment">/* pkt len in words, w/o this word */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">rtcp_common_t</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RTP-协议介绍&quot;&gt;&lt;a href=&quot;#RTP-协议介绍&quot; class=&quot;headerlink&quot; title=&quot;RTP 协议介绍&quot;&gt;&lt;/a&gt;RTP 协议介绍&lt;/h2&gt;&lt;p&gt;实时传输协议 RTP（Real-time Transport Protocol）是一个网络传</summary>
      
    
    
    
    <category term="音视频" scheme="http://example.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="流媒体协议" scheme="http://example.com/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>APK 瘦身</title>
    <link href="http://example.com/2019/04/30/APK%E7%98%A6%E8%BA%AB/"/>
    <id>http://example.com/2019/04/30/APK%E7%98%A6%E8%BA%AB/</id>
    <published>2019-04-30T09:06:19.000Z</published>
    <updated>2022-06-30T01:20:01.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APK-结构"><a href="#APK-结构" class="headerlink" title="APK 结构"></a>APK 结构</h2><p>在讨论如何减小应用的大小之前，了解应用 APK 的结构会很有帮助。APK 文件由 Zip 压缩文件（其中包含构成应用的所有文件）组成。这些文件包括 Java 类文件、资源文件和包含已编译资源的文件。</p><p>APK 包含以下目录：</p><ul><li><code>META-INF/</code>：包含 <code>CERT.SF</code> 和 <code>CERT.RSA</code> 签名文件，以及 <code>MANIFEST.MF</code> 清单文件。</li><li><code>assets/</code>：包含应用的资源；应用可以使用 <a href="https://developer.android.com/reference/android/content/res/AssetManager.html?hl=zh-CN">AssetManager</a> 对象检索这些资源。</li><li><code>res/</code>：包含未编译到 <code>resources.arsc</code> 中的资源。</li><li><code>lib/</code>：包含特定于处理器软件层的编译代码。此目录包含每种平台类型的子目录，如 <code>armeabi</code>、<code>armeabi-v7a</code>、<code>arm64-v8a</code>、<code>x86</code>、<code>x86_64</code> 和 <code>mips</code>。</li></ul><p>APK 还包含以下文件。在这些文件中，只有 <code>AndroidManifest.xml</code> 是必需的。</p><ul><li><code>resources.arsc</code>：包含已编译的资源。此文件包含 <code>res/values/</code> 文件夹的所有配置中的 XML 内容。打包工具会提取此 XML 内容，将其编译为二进制文件形式，并将相应内容进行归档。此内容包括语言字符串和样式，以及未直接包含在 <code>resources.arsc</code> 文件中的内容（例如布局文件和图片）的路径。</li><li><code>classes.dex</code>：包含以 Dalvik/ART 虚拟机可理解的 DEX 文件格式编译的类。</li><li><code>AndroidManifest.xml</code>：包含核心 Android 清单文件。此文件列出了应用的名称、版本、访问权限和引用的库文件。该文件使用 Android 的二进制 XML 格式。</li></ul><h2 id="减少资源数量和大小"><a href="#减少资源数量和大小" class="headerlink" title="减少资源数量和大小"></a>减少资源数量和大小</h2><p>APK 的大小会影响应用加载速度、使用的内存量以及消耗的电量。减小 APK 大小的一种简单方法是减少其包含的资源数量和大小。具体来说，您可以移除应用不再使用的资源，并且可以用可伸缩的 <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html?hl=zh-CN">Drawable</a> 对象取代图片文件。此部分将讨论上述这些方法，以及另外几种可减少应用中的资源以减小 APK 总大小的方法。</p><h3 id="移除未使用的资源"><a href="#移除未使用的资源" class="headerlink" title="移除未使用的资源"></a>移除未使用的资源</h3><p><a href="https://developer.android.com/studio/write/lint.html?hl=zh-CN">lint</a> 工具是 Android Studio 中附带的静态代码分析器，可检测到 <code>res/</code> 文件夹中未被代码引用的资源。当 <code>lint</code> 工具发现项目中有可能未使用的资源时，会显示一条消息，如下例所示。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">res/layout/preferences.xml: Warning: The resource R.layout.preferences appears to be unused [UnusedResources]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>lint</code> 工具不会扫描 <code>assets/</code> 文件夹、通过反射引用的资源或已链接到应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。</p><p>您添加到代码的库可能包含未使用的资源。如果您在应用的 <code>build.gradle</code> 文件中启用了 <a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-CN">shrinkResources</a>，则 Gradle 可以代表您自动移除资源。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123; </span><br><span class="line">    &#123; </span><br><span class="line">        release &#123; </span><br><span class="line">            minifyEnabled <span class="literal">true</span> </span><br><span class="line">            shrinkResources <span class="literal">true</span> </span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用 <code>shrinkResources</code>，您必须启用代码压缩功能。在编译过程中，首先，<a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-CN">ProGuard</a> 会移除未使用的代码，但会保留未使用的资源。然后，Gradle 会移除未使用的资源。</p><p>要详细了解 ProGuard 以及 Android Studio 帮助您减小 APK 大小的其他方式，请参见 <a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-CN">压缩代码和资源</a>。</p><p>在 Android Gradle Plugin 0.7 及更高版本中，您可以声明应用支持的配置。Gradle 会使用 <code>resConfig</code> 和 <code>resConfigs</code> 风格以及 <code>defaultConfig</code> 选项将这些信息传递给编译系统。随后，编译系统会阻止来自其他不受支持配置的资源出现在 APK 中，从而减小 APK 的大小。有关此功能的详情，请参见 <a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-CN#unused-alt-resources">移除未使用的备用资源</a>。</p><h3 id="减少库中的资源使用"><a href="#减少库中的资源使用" class="headerlink" title="减少库中的资源使用"></a>减少库中的资源使用</h3><p>在开发 Android 应用时，您通常需要使用外部库来提高应用的可用性和多功能性。例如，您可以引用 <a href="https://developer.android.com/topic/libraries/support-library/index.html?hl=zh-CN">Android 支持库</a> 来提升旧设备上的用户体验，也可以使用 <a href="https://developers.google.com/android/guides/overview?hl=zh-CN">Google Play 服务</a> 检索应用中文本的自动翻译。</p><p>如果库是为服务器或桌面设备设计的，则它可能包含应用不需要的许多对象和方法。要仅包含您的应用所需的库部分，您可以编辑库的文件（如果相应的许可允许您修改库）。您还可以使用其他适合移动设备的库来为应用添加特定功能。</p><p><strong>注意</strong>：<a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-CN">ProGuard</a> 可以清理随库导入的一些不必要代码，但它无法移除库的大型内部依赖项。</p><h3 id="仅支持特定密度"><a href="#仅支持特定密度" class="headerlink" title="仅支持特定密度"></a>仅支持特定密度</h3><p>Android 支持数量非常广泛的设备（包含各种屏幕密度）。在 Android 4.4（API 级别 19）及更高版本中，框架支持各种密度：<code>ldpi</code>、<code>mdpi</code>、<code>tvdpi</code>、<code>hdpi,</code>、<code>xhdpi</code>、<code>xxhdpi</code> 和 <code>xxxhdpi</code>。尽管 Android 支持所有这些密度，但您无需将光栅化资源导出到每个密度。</p><p>如果您知道只有一小部分用户拥有具有特定密度的设备，请考虑是否需要将这些密度捆绑到您的应用中。如果您不添加用于特定屏幕密度的资源，Android 会自动扩缩最初为其他屏幕密度设计的现有资源。</p><p>如果您的应用仅需要扩缩的图片，则可以通过在 <code>drawable-nodpi/</code> 中使用图片的单个变体来节省更多空间。我们建议每个应用至少包含一个 <code>xxhdpi</code> 图片变体。</p><p>有关屏幕密度的详情，请参见 <a href="https://developer.android.com/about/dashboards/index.html?hl=zh-CN#Screens">屏幕尺寸和密度</a>。</p><h3 id="使用可绘制对象"><a href="#使用可绘制对象" class="headerlink" title="使用可绘制对象"></a>使用可绘制对象</h3><p>某些图片不需要静态图片资源；框架可以在运行时改为动态绘制图片。<a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html?hl=zh-CN">Drawable</a> 对象（XML 中为 <code>&lt;shape&gt;</code>）会占用 APK 中的少量空间。此外，XML <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html?hl=zh-CN">Drawable</a> 对象会生成符合 Material Design 准则的单色图片。</p><h3 id="重复使用资源"><a href="#重复使用资源" class="headerlink" title="重复使用资源"></a>重复使用资源</h3><p>您可以为图片的变体添加单独的资源，例如同一图片经过色调调整、阴影设置或旋转的版本。不过，我们建议您重复使用同一组资源，并在运行时根据需要对其进行自定义。</p><p>Android 提供了一些实用程序来更改资源的颜色，每个实用程序在 Android 5.0（API 级别 21）及更高版本上都使用 <code>android:tint</code> 和 <code>tintMode</code> 属性。对于较低版本的平台，则使用 <a href="https://developer.android.com/reference/android/graphics/ColorFilter.html?hl=zh-CN">ColorFilter</a> 类。</p><p>您还可以省略仅是另一个资源的旋转等效项的资源。以下代码段提供了一个示例，展示了通过绕图片中心位置旋转 180 度，将“拇指向上”变为“拇指向下”：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/ic_thumb_up&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:fromDegrees</span>=<span class="string">&quot;180&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从代码进行渲染"><a href="#从代码进行渲染" class="headerlink" title="从代码进行渲染"></a>从代码进行渲染</h3><p>您还可以通过按一定程序渲染图片来减小 APK 大小。按一定程序渲染可以释放空间，因为您不再在 APK 中存储图片文件。</p><h3 id="压缩-PNG-文件"><a href="#压缩-PNG-文件" class="headerlink" title="压缩 PNG 文件"></a>压缩 PNG 文件</h3><p><code>aapt</code> 工具可以在编译过程中通过无损压缩来优化放置在 <code>res/drawable/</code> 中的图片资源。例如，<code>aapt</code> 工具可以通过调色板将不需要超过 256 种颜色的真彩色 PNG 转换为 8 位 PNG。这样做会生成质量相同但内存占用量更小的图片。</p><p>请记住，<code>aapt</code> 具有以下限制：</p><ul><li><p><code>aapt</code> 工具不会压缩 <code>asset/</code> 文件夹中包含的 PNG 文件。</p></li><li><p>图片文件需要使用 256 种或更少的颜色才可供 <code>aapt</code> 工具进行优化。</p></li><li><p><code>aapt</code> 工具可能会增大已压缩 PNG 文件。为防止出现这种情况，您可以使用 Gradle 中的 <code>cruncherEnabled</code> 标记为 PNG 文件停用此过程：</p><p><code> aaptOptions &#123; cruncherEnabled = false &#125;</code></p></li></ul><h3 id="压缩-PNG-和-JPEG-文件"><a href="#压缩-PNG-和-JPEG-文件" class="headerlink" title="压缩 PNG 和 JPEG 文件"></a>压缩 PNG 和 JPEG 文件</h3><p>您可以使用 <a href="http://pmt.sourceforge.net/pngcrush/">pngcrush</a>、<a href="https://pngquant.org/">pngquant</a> 或 <a href="https://github.com/google/zopfli">zopflipng</a> 等工具减小 PNG 文件的大小，同时不损失画质。所有这些工具都可以减小 PNG 文件的大小，同时保持肉眼感知的画质不变。</p><p><code>pngcrush</code> 工具尤为有效：该工具会迭代 PNG 过滤器和 zlib(Deflate) 参数，使用过滤器和参数的每个组合来压缩图片。然后，它会选择可产生最小压缩输出的配置。</p><p>要压缩 JPEG 文件，您可以使用 <a href="http://www.elektronik.htw-aalen.de/packjpg/">packJPG</a> 和 <a href="https://github.com/google/guetzli">guetzli</a> 等工具。</p><h3 id="使用-WebP-文件格式"><a href="#使用-WebP-文件格式" class="headerlink" title="使用 WebP 文件格式"></a>使用 WebP 文件格式</h3><p>如果以 Android 3.2（API 级别 13）及更高版本为目标，您还可以使用 <a href="https://developers.google.com/speed/webp/?hl=zh-CN">WebP</a> 文件格式的图片（而不是使用 PNG 或 JPEG 文件）。WebP 格式提供有损压缩（如 JPEG）以及透明度（如 PNG），不过与 JPEG 或 PNG 相比，这种格式可以提供更好的压缩效果。</p><p>您可以使用 Android Studio 将现有 BMP、JPG、PNG 或静态 GIF 图片转换为 WebP 格式。有关详情，请参见 <a href="https://developer.android.com/studio/write/convert-webp.html?hl=zh-CN">使用 Android Studio 创建 WebP 图片</a>。</p><p><strong>注意</strong>：仅当 <a href="https://material.io/guidelines/style/icons.html#icons-product-icons">启动器图标</a> 使用 PNG 格式时，Google Play 才会接受 APK。</p><h3 id="使用矢量图形"><a href="#使用矢量图形" class="headerlink" title="使用矢量图形"></a>使用矢量图形</h3><p>您可以使用矢量图形创建与分辨率无关的图标和其他可伸缩媒体。使用这些图形可以极大地减少 APK 占用的空间。矢量图片在 Android 中以 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html?hl=zh-CN">VectorDrawable</a> 对象的形式表示。借助 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html?hl=zh-CN">VectorDrawable</a> 对象，100 字节的文件可以生成与屏幕大小相同的清晰图片。</p><p>不过，系统渲染每个 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html?hl=zh-CN">VectorDrawable</a> 对象需要花费大量时间，而较大的图片则需要更长的时间才能显示在屏幕上。因此，请考虑仅在显示小图片时使用这些矢量图形。</p><p>有关使用 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html?hl=zh-CN">VectorDrawable</a> 对象的详情，请参见 <a href="https://developer.android.com/training/material/drawables.html?hl=zh-CN">使用可绘制资源</a>。</p><p>将矢量图形用于动画图片</p><p>请勿使用 <a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html?hl=zh-CN">AnimationDrawable</a> 创建逐帧动画，因为这样做需要为动画的每个帧添加单独的位图文件，而这会大大增加 APK 的大小。</p><p>您应改为使用 <a href="https://developer.android.com/reference/android/support/graphics/drawable/AnimatedVectorDrawableCompat.html?hl=zh-CN">AnimatedVectorDrawableCompat</a> 创建 <a href="https://developer.android.com/training/material/animations.html?hl=zh-CN#AnimVector">动画矢量可绘制资源</a>。</p><h2 id="减少原生和-Java-代码"><a href="#减少原生和-Java-代码" class="headerlink" title="减少原生和 Java 代码"></a>减少原生和 Java 代码</h2><p>您可以使用多种方法来减小应用中 Java 和原生代码库的大小。</p><p>移除不必要的生成代码</p><p>确保了解自动生成的任何代码所占用的空间。例如，许多协议缓冲区工具会生成过多的方法和类，这可能会使应用的大小增加一倍或两倍。</p><p>避免使用枚举</p><p>单个枚举会使应用的 <code>classes.dex</code> 文件增加大约 1.0 到 1.4 KB 的大小。这些增加的大小会快速累积，产生复杂的系统或共享库。如果可能，请考虑使用 <code>@IntDef</code> 注释和 <a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-CN">ProGuard</a> 移除枚举并将它们转换为整数。此类型转换可保留枚举的各种安全优势。</p><p>减小原生二进制文件的大小</p><p>如果您的应用使用原生代码和 Android NDK，您还可以通过优化代码来减小发布版本应用的大小。移除调试符号和不提取原生库是两项很实用的技术。</p><h3 id="移除调试符号"><a href="#移除调试符号" class="headerlink" title="移除调试符号"></a>移除调试符号</h3><p>如果应用正在开发中且仍需要调试，则使用调试符号非常合适。您可以使用 Android NDK 中提供的 <code>arm-eabi-strip</code> 工具从原生库中移除不必要的调试符号。之后，您便可以编译发布版本。</p><h3 id="避免解压缩原生库"><a href="#避免解压缩原生库" class="headerlink" title="避免解压缩原生库"></a>避免解压缩原生库</h3><p>在编译应用的发布版本时，您可以通过在应用清单的 <a href="https://developer.android.com/guide/topics/manifest/application-element.html?hl=zh-CN">application</a> 元素中设置 <code>android:extractNativeLibs=&quot;false&quot;</code>，打包 APK 中未压缩的 <strong><code>.so</code></strong> 文件。停用此标记可防止 <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html?hl=zh-CN">PackageManager</a> 在安装过程中将 <code>.so</code> 文件从 APK 复制到文件系统，并具有减小应用更新的额外好处。</p><h2 id="维持多个精简-APK"><a href="#维持多个精简-APK" class="headerlink" title="维持多个精简 APK"></a>维持多个精简 APK</h2><p>APK 可能包含用户下载但从不使用的内容，例如其他语言或针对屏幕密度的资源。要确保为用户提供最小的下载文件，您应该 <a href="https://developer.android.com/topic/performance/reduce-apk-size?hl=zh-CN#app_bundle">使用 Android App Bundle</a> 将应用上传到 Google Play。通过上传 App Bundle，Google Play 能够针对每位用户的设备配置生成并提供经过优化的 APK，因此用户只需下载运行您的应用所需的代码和资源。您无需再编译、签署和管理多个 APK 以支持不同的设备，而用户也可以获得更小、更优化的下载文件包。</p><p>如果您不打算将应用发布到 Google Play，则可以将应用细分为多个 APK，并按屏幕尺寸或 GPU 纹理支持等因素进行区分。</p><p>当用户下载您的应用时，他们的设备会根据设备的功能和设置接收正确的 APK。这样，设备不会接收用于设备所不具备的功能的资源。例如，如果用户具有 <code>hdpi</code> 设备，则不需要您可能会为具有更高密度显示器的设备提供的 <code>xxxhdpi</code> 资源。</p><p>有关详情，请参见 <a href="https://developer.android.com/studio/build/configure-apk-splits.html?hl=zh-CN">配置 APK 拆分</a> 和 <a href="https://developer.android.com/training/multiple-apks/index.html?hl=zh-CN">维持多个 APK</a>。</p><h2 id="减少-Native-体积"><a href="#减少-Native-体积" class="headerlink" title="减少 Native 体积"></a>减少 Native 体积</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//在 defaultConfig 节点下配置 externalNativeBuild 块</span></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            <span class="comment">// For ndk-build, instead use ndkBuild &#123;&#125;</span></span><br><span class="line">            cmake &#123; <span class="comment">//指定 cmake 的编译选项</span></span><br><span class="line">                <span class="comment">// Sets optional flags for the C compiler.</span></span><br><span class="line">                cFlags <span class="string">&quot;-fvisibility=hidden  -ffunction-sections -fdata-sections&quot;</span></span><br><span class="line">                <span class="comment">// Sets optional flags for the C++ compiler.</span></span><br><span class="line">                cppFlags <span class="string">&quot;-fvisibility=hidden  -ffunction-sections -fdata-sections -std=c++11&quot;</span></span><br><span class="line"></span><br><span class="line">                arguments <span class="string">&quot;-DANDROID_TOOLCHAIN=gcc&quot;</span><span class="comment">//设置使用 gcc 编译，cmake 默认使用 clang 编译</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;APK-结构&quot;&gt;&lt;a href=&quot;#APK-结构&quot; class=&quot;headerlink&quot; title=&quot;APK 结构&quot;&gt;&lt;/a&gt;APK 结构&lt;/h2&gt;&lt;p&gt;在讨论如何减小应用的大小之前，了解应用 APK 的结构会很有帮助。APK 文件由 Zip 压缩文件（其中包含</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="优化" scheme="http://example.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>shutdown 和 close</title>
    <link href="http://example.com/2018/03/15/sokcet%E7%9A%84shutdown%E5%92%8Cclose/"/>
    <id>http://example.com/2018/03/15/sokcet%E7%9A%84shutdown%E5%92%8Cclose/</id>
    <published>2018-03-15T06:41:21.000Z</published>
    <updated>2022-06-30T01:20:01.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>转载自：<a href="http://www.cnblogs.com/wainiwann/p/3942203.html">http://www.cnblogs.com/wainiwann/p/3942203.html</a></p><p>在开发的一个基于 rtmp 聊天的程序时发现了一个很奇怪的现象。</p><p>在 windows 下当我们执行 closesocket 的操作之后，阻塞的 recv 会立即返回 -1 。</p><p>而在 linux 下当我们执行 close 操作之后阻塞的 recv 会出现不能立即返回的现象。后来在网上一搜发现很多遇到类似这种现象的情况，大致意思应该是</p><p>当 socket 被动被 close 的时候进入了“CLOSE_WAIT（被动关闭一方）”的情况。<br>解决方法就是在你 close 之前调用一下：</p><p><code>shutdown(socket, SHUT_RDWR)</code></p><p>就是关闭 socket 的读写功能。</p><h2 id="Shutdown-和-Close"><a href="#Shutdown-和-Close" class="headerlink" title="Shutdown 和 Close"></a>Shutdown 和 Close</h2><blockquote><p>下面是对譬如“CLOSE_WAIT”现象的一些解释</p></blockquote><p>主动关闭方和被动方经历的状态：</p><p>FIN_WAIT_1（主动关闭一方）：当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，</p><p>FIN_WAIT_2（主动关闭一方）：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</p><p>TIME_WAIT（主动关闭一方）：表示收到了对方的 FIN 报文，并发送出了 ACK 报文就等 2MSL（2 倍最大生存时间）后即可回到 CLOSED 可用状态了。</p><p>CLOSE_WAIT（被动关闭一方）：这种状态的含义其实是表示在等待关闭。当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</p><p>LAST_ACK（被动关闭一方）：它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态</p><blockquote><p>下面是 socket 的 close 和 shutdown 的一些说明</p></blockquote><p>Linux socket 关闭连接的方法有两种分别是 shutdown 和 close，首先看一下 shutdown 的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure><p>how 的方式有三种分别是</p><ul><li><p>SHUT_RD（0）：关闭 sockfd 上的读功能，此选项将不允许 sockfd 进行读操作。</p></li><li><p>SHUT_WR（1）：关闭 sockfd 的写功能，此选项将不允许 sockfd 进行写操作。</p></li><li><p>SHUT_RDWR（2）：关闭 sockfd 的读写功能。</p></li></ul><p>成功则返回 0，错误返回 -1，错误码 errno：EBADF 表示 sockfd 不是一个有效描述符；ENOTCONN 表示 sockfd 未连接；ENOTSOCK 表示 sockfd 是一个文件描述符而不是 socket 描述符。</p><p>close 的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>关闭读写。</p><p>  成功则返回 0，错误返回 -1，错误码 errno：EBADF 表示 fd 不是一个有效描述符；EINTR 表示 close 函数被信号中断；EIO 表示一个 IO 错误。<br>  下面摘用网上的一段话来说明二者的区别：<br>  close–关闭本进程的 socket id，但链接还是开着的，用这 socket id 的其它进程还能用这个链接，能读或写这个 socket id<br>  shutdown–则破坏了 socket 链接，读的时候可能侦探到 EOF 结束符，写的时候可能会收到一个 SIGPIPE 信号，这个信号可能直到 socket buffer 被填充了才收到，shutdown 还有一个关闭方式的参数，0 不能再读，1 不能再写，2 读写都不能。</p><blockquote><p>socket 多进程中的 shutdown, close 使用</p></blockquote><p>  当所有的数据操作结束以后，你可以调用 close() 函数来释放该 socket，从而停止在该 socket 上的任何数据操作：close(sockfd);</p><p>  你也可以调用 shutdown() 函数来关闭该 socket。该函数允许你只停止在某个方向上的数据传输，而一个方向上的数据传输继续进行。如你可以关闭某 socket 的写操作而允许继续在该 socket 上接受数据，直至读入所有数据。</p><p>  int shutdown(int sockfd,int how);</p><p>  sockfd 是需要关闭的 socket 的描述符。参数 how 允许为 shutdown 操作选择以下几种方式：</p><ul><li><p>SHUT_RD：关闭连接的读端。也就是该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被丢弃。进程将不能对该套接字发出任何读操作。对 TCP 套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。</p></li><li><p>SHUT_WR：关闭连接的写端，进程不能在对此套接字发出写操作。</p></li><li><p>SHUT_RDWR：相当于调用 shutdown 两次；首先是以 SHUT_RD，然后以 SHUT_WR<br>使用 close 中止一个连接，但它只是减少描述符的参考数，并不直接关闭连接，只有当描述符的参考数为 0 时才关闭连接。<br>shutdown 可直接关闭描述符，不考虑描述符的参考数，可选择中止一个方向的连接。</p><p><strong>注意：</strong></p><p> 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。<br> 在多进程中如果一个进程中 <code>shutdown(sfd, SHUT_RDWR)</code> 后其它的进程将无法进行通信。如果一个进程 <code>close(sfd)</code> 将不会影响到其它进程，得自己理解引用计数的用法了，有 Kernel 编程知识的更好理解了。</p></li></ul><blockquote><p>更多关于 close 和 shutdown 的说明</p></blockquote><ol><li>只要 TCP 栈的读缓冲里还有未读取（read）数据，则调用 close 时会直接向对端发送 RST。</li><li>shutdown 与 socket 描述符没有关系，即使调用 <code>shutdown(fd, SHUT_RDWR)</code> 也不会关闭 fd，最终还需 <code>close(fd)</code>。</li><li>可以认为 <code>shutdown(fd, SHUT_RD)</code> 是空操作，因为 shutdown 后还可以继续从该 socket 读取数据，这点也许还需要进一步证实。</li><li>在已发送 FIN 包后 write 该 socket 描述符会引发 EPIPE/SIGPIPE。</li><li>当有多个 socket 描述符指向同一 socket 对象时，调用 close 时首先会递减该对象的引用计数，计数为 0 时才会发送 FIN 包结束 TCP 连接。shutdown 不同，只要以 SHUT_WR/SHUT_RDWR 方式调用即发送 FIN 包。</li><li>SO_LINGER 与 close，当 SO_LINGER 选项开启但超时值为 0 时，调用 close 直接发送 RST（这样可以避免进入 TIME_WAIT 状态，但破坏了 TCP 协议的正常工作方式），SO_LINGER 对 shutdown 无影响。</li><li>TCP 连接上出现 RST 与随后可能的 TIME_WAIT 状态没有直接关系，主动发 FIN 包方必然会进入 TIME_WAIT 状态，除非不发送 FIN 而直接以发送 RST 结束连接。</li></ol><blockquote><p>下面是对于该主题相关网络讨论资料总结</p></blockquote><p><a href="http://bbs.csdn.net/topics/350147238">http://bbs.csdn.net/topics/350147238</a><br><a href="http://bbs.csdn.net/topics/350050711">http://bbs.csdn.net/topics/350050711</a><br><a href="http://blog.csdn.net/helpxs/article/details/6661951">http://blog.csdn.net/helpxs/article/details/6661951</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;转载自：&lt;a href=&quot;http://www.cnblogs.com/wainiwann/p/3942203.html&quot;&gt;http://w</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
</feed>
